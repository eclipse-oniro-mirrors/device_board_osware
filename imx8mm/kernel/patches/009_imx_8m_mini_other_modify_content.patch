commit 0af2a79822f6b77e33293f4187d606c94e293d59
Author: zhaoxc0502 <zhaoxc0502@thundersoft.com>
Date:   Wed Jun 1 12:05:44 2022 +0800

    modify kernel other for imx8m mini
    
    Change-Id: I6d60882a5b2f6956b77181270bd3c8da5eeff330

diff --git a/MAINTAINERS b/MAINTAINERS
index 4fef10dd2..2f2a97bd6 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -6585,6 +6585,8 @@ F:	Documentation/devicetree/bindings/net/mdio*
 F:	Documentation/devicetree/bindings/net/qca,ar803x.yaml
 F:	Documentation/networking/phy.rst
 F:	drivers/net/mdio/
+F:	drivers/net/mdio/acpi_mdio.c
+F:	drivers/net/mdio/fwnode_mdio.c
 F:	drivers/net/mdio/of_mdio.c
 F:	drivers/net/pcs/
 F:	drivers/net/phy/
@@ -7067,6 +7069,14 @@ F:	drivers/ptp/ptp_qoriq.c
 F:	drivers/ptp/ptp_qoriq_debugfs.c
 F:	include/linux/fsl/ptp_qoriq.h
 
+FREESCALE QORIQ PPFE ETHERNET DRIVER
+M:	Anji Jagarlmudi <anji.jagarlmudi@nxp.com>
+M:	Calvin Johnson <calvin.johnson@nxp.com>
+L:	netdev@vger.kernel.org
+S:	Maintained
+F:	drivers/staging/fsl_ppfe
+F:	Documentation/devicetree/bindings/net/fsl_ppfe/pfe.txt
+
 FREESCALE QUAD SPI DRIVER
 M:	Han Xu <han.xu@nxp.com>
 L:	linux-spi@vger.kernel.org
@@ -8580,6 +8590,12 @@ S:	Maintained
 F:	Documentation/devicetree/bindings/iio/multiplexer/io-channel-mux.txt
 F:	drivers/iio/multiplexer/iio-mux.c
 
+IIO SCMI BASED DRIVER
+M:	Jyoti Bhayana <jbhayana@google.com>
+L:	linux-iio@vger.kernel.org
+S:	Maintained
+F:	drivers/iio/common/scmi_sensors/scmi_iio.c
+
 IIO SUBSYSTEM AND DRIVERS
 M:	Jonathan Cameron <jic23@kernel.org>
 R:	Lars-Peter Clausen <lars@metafoo.de>
@@ -9393,6 +9409,7 @@ L:	jailhouse-dev@googlegroups.com
 S:	Maintained
 F:	arch/x86/include/asm/jailhouse_para.h
 F:	arch/x86/kernel/jailhouse.c
+F:	drivers/virt/jailhouse_dbgcon.c
 
 JC42.4 TEMPERATURE SENSOR DRIVER
 M:	Guenter Roeck <linux@roeck-us.net>
@@ -9731,6 +9748,18 @@ F:	include/keys/trusted-type.h
 F:	include/keys/trusted_tpm.h
 F:	security/keys/trusted-keys/
 
+KEYS-SECURE
+M:	Udit Agarwal <udit.agarwal@nxp.com>
+R:	Sahil Malhotra <sahil.malhotra@nxp.com>
+L:	linux-security-module@vger.kernel.org
+L:	keyrings@vger.kernel.org
+S:	Supported
+F:	include/keys/secure-type.h
+F:	security/keys/secure_key.c
+F:	security/keys/securekey_desc.c
+F:	security/keys/securekey_desc.h
+F:	security/keys/encrypted-keys/masterkey_secure.c
+
 KEYS/KEYRINGS
 M:	David Howells <dhowells@redhat.com>
 M:	Jarkko Sakkinen <jarkko@kernel.org>
@@ -13410,6 +13439,7 @@ F:	include/uapi/linux/switchtec_ioctl.h
 PCI DRIVER FOR MOBIVEIL PCIE IP
 M:	Karthikeyan Mitran <m.karthikeyan@mobiveil.co.in>
 M:	Hou Zhiqiang <Zhiqiang.Hou@nxp.com>
+M:	Xiaowei Bao <xiaowei.bao@nxp.com>
 L:	linux-pci@vger.kernel.org
 S:	Supported
 F:	Documentation/devicetree/bindings/pci/mobiveil-pcie.txt
@@ -13432,11 +13462,13 @@ F:	drivers/pci/controller/pci-tegra.c
 
 PCI DRIVER FOR NXP LAYERSCAPE GEN4 CONTROLLER
 M:	Hou Zhiqiang <Zhiqiang.Hou@nxp.com>
+M:	Xiaowei Bao <xiaowei.bao@nxp.com>
 L:	linux-pci@vger.kernel.org
 L:	linux-arm-kernel@lists.infradead.org
 S:	Maintained
 F:	Documentation/devicetree/bindings/pci/layerscape-pcie-gen4.txt
 F:	drivers/pci/controller/mobiveil/pcie-layerscape-gen4.c
+F:	drivers/pci/controller/mobiveil/pcie-layerscape-gen4-ep.c
 
 PCI DRIVER FOR RENESAS R-CAR
 M:	Marek Vasut <marek.vasut+renesas@gmail.com>
@@ -14423,6 +14455,8 @@ S:	Maintained
 F:	Documentation/devicetree/bindings/misc/fsl,qoriq-mc.txt
 F:	Documentation/networking/device_drivers/ethernet/freescale/dpaa2/overview.rst
 F:	drivers/bus/fsl-mc/
+F:	include/uapi/linux/fsl_mc.h
+F:	Documentation/ABI/stable/sysfs-bus-fsl-mc
 
 QT1010 MEDIA DRIVER
 M:	Antti Palosaari <crope@iki.fi>
@@ -16950,6 +16984,7 @@ F:	drivers/mfd/syscon.c
 
 SYSTEM CONTROL & POWER/MANAGEMENT INTERFACE (SCPI/SCMI) Message Protocol drivers
 M:	Sudeep Holla <sudeep.holla@arm.com>
+R:	Cristian Marussi <cristian.marussi@arm.com>
 L:	linux-arm-kernel@lists.infradead.org
 S:	Maintained
 F:	Documentation/devicetree/bindings/arm/arm,sc[mp]i.txt
@@ -16957,6 +16992,7 @@ F:	drivers/clk/clk-sc[mp]i.c
 F:	drivers/cpufreq/sc[mp]i-cpufreq.c
 F:	drivers/firmware/arm_scmi/
 F:	drivers/firmware/arm_scpi.c
+F:	drivers/regulator/scmi-regulator.c
 F:	drivers/reset/reset-scmi.c
 F:	include/linux/sc[mp]i_protocol.h
 F:	include/trace/events/scmi.h
diff --git a/MAINTAINERS.NXP b/MAINTAINERS.NXP
new file mode 100644
index 000000000..9ce56fb57
--- /dev/null
+++ b/MAINTAINERS.NXP
@@ -0,0 +1,1222 @@
+List of maintainers
+====================================================
+
+Descriptions of section entries
+-------------------------------
+
+    M: *Mail* patches to: FullName <address@domain>
+    R: Designated *Reviewer*: FullName <address@domain>
+       These reviewers should be CCed on patches.
+    L: *Mailing list* that is relevant to this area
+    S: *Status*, one of the following:
+       Supported:   Someone is actually paid to look after this.
+       Maintained:  Someone actually looks after it.
+       Odd Fixes:   It has a maintainer but they don't have time to do
+            much other than throw the odd patch in. See below..
+       Orphan:  No current maintainer [but maybe you could take the
+            role as you write your new code].
+       Obsolete:    Old code. Something tagged obsolete generally means
+            it has been replaced by a better system and you
+            should be using that.
+    F: *Files* and directories wildcard patterns.
+       A trailing slash includes all files and subdirectory files.
+       F:   drivers/net/    all files in and below drivers/net
+       F:   drivers/net/*   all files in drivers/net, but not below
+       F:   */net/*     all files in "any top level directory"/net
+       One pattern per line.  Multiple F: lines acceptable.
+    N: Files and directories *Regex* patterns.
+       N:   [^a-z]tegra all files whose path contains the word tegra
+       One pattern per line.  Multiple N: lines acceptable.
+       scripts/get_maintainer.pl has different behavior for files that
+       match F: pattern and matches of N: patterns.  By default,
+       get_maintainer will not look at git log history when an F: pattern
+       match occurs.  When an N: match occurs, git log history is used
+       to also notify the people that have git commit signatures.
+    X: *Excluded* files and directories that are NOT maintained, same
+       rules as F:. Files exclusions are tested before file matches.
+       Can be useful for excluding a specific subdirectory, for instance:
+       F:   net/
+       X:   net/ipv6/
+       matches all files in and below net excluding net/ipv6/
+
+Note for sections
+-----------------
+
+    Name:
+        X:   subsystem(X)
+        X/Y: IP(Y) under subsystem(X)
+    Order:
+        Need match the order for auto-merge. When adding to this list,
+        please keep the new entry after its dependent ones.
+    Requirement:
+        At least one M: entry is needed after each section. Otherwise, the
+        section will be viewed as unmaintained and obsolete.
+
+Maintainers List
+----------------
+
+base
+M: Aisheng Dong <aisheng.dong@nxp.com>
+M: Li Yang <leoyang.li@nxp.com>
+
+core
+M: Aisheng Dong <aisheng.dong@nxp.com>
+M: Li Yang <leoyang.li@nxp.com>
+
+adc
+M: Haibo Chen <haibo.chen@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: drivers/iio/adc/
+
+arch/core
+M: Alison Wang <alison.wang@nxp.com>
+M: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
+M: Dong Aisheng <aisheng.dong@nxp.com>
+M: Li Yang <leoyang.li@nxp.com>
+F: arch/arm/
+X: arch/arm/boot/dts/
+X: arch/arm/mach-imx/
+F: arch/arm64/
+X: arch/arm64/boot/dts/
+F: arch/powerpc/
+X: arch/powerpc/boot/dts/
+X: arch/powerpc/platforms/
+X: arch/powerpc/sysdev/
+
+arch/imx
+M: Alison Wang <alison.wang@nxp.com>
+M: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
+M: Peng Fan <peng.fan@nxp.com>
+M: Abel Vesa <abel.vesa@nxp.com>
+F: arch/arm/mach-imx/
+F: drivers/soc/imx/
+F: include/linux/busfreq-imx.h
+F: include/linux/mfd/syscon/imx*
+F: include/linux/mx8_mu.h
+F: include/soc/imx/
+
+arch/qoriq
+M: Alison Wang <alison.wang@nxp.com>
+M: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
+M: Li Yang <leoyang.li@nxp.com>
+F: Documentation/devicetree/bindings/powerpc/fsl/
+F: arch/powerpc/platforms/
+F: arch/powerpc/sysdev/
+F: drivers/soc/fsl/
+
+audio/asrc
+M: Alison Wang <alison.wang@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+F: include/uapi/linux/*asrc*
+F: sound/soc/fsl/*asrc*
+
+audio/audmix
+M: Alison Wang <alison.wang@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+M: Viorel Suman <viorel.suman@nxp.com>
+F: sound/soc/fsl/imx-audmix.c
+
+audio/audmux
+M: Alison Wang <alison.wang@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+F: sound/soc/fsl/imx-audmux*
+
+audio/card
+M: Alison Wang <alison.wang@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+M: Viorel Suman <viorel.suman@nxp.com>
+M: Daniel Baluta <daniel.baluta@nxp.com>
+F: Documentation/devicetree/bindings/sound/
+F: sound/soc/fsl/
+
+audio/codec
+M: Alison Wang <alison.wang@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+F: sound/soc/codecs/
+
+audio/dma
+M: Alison Wang <alison.wang@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+F: sound/soc/fsl/imx-pcm*
+
+audio/dsp
+M: Alison Wang <alison.wang@nxp.com>
+M: Daniel Baluta <daniel.baluta@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+F: Documentation/devicetree/bindings/sound/fsl,dsp.txt
+F: include/uapi/linux/mxc_dsp.h
+F: sound/soc/fsl/fsl_dsp*
+F: sound/soc/fsl/imx-dsp*
+
+audio/esai
+M: Alison Wang <alison.wang@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+F: sound/soc/fsl/fsl_esai.c
+
+audio/fm
+M: Alison Wang <alison.wang@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+F: Documentation/devicetree/bindings/sound/imx-audio-si476x.txt
+F: drivers/media/radio/radio-si476x.c
+F: drivers/mfd/si476x-i2c.c
+F: include/linux/mfd/si476x-core.h
+F: sound/soc/fsl/imx-si476x.c
+
+audio/hdmi
+M: Alison Wang <alison.wang@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+F: Documentation/devicetree/bindings/sound/imx-audio-cdnhdmi.txt
+F: sound/soc/codecs/hdmi-codec.c
+F: sound/soc/fsl/fsl_hdmi.c
+F: sound/soc/fsl/hdmi_pcm.S
+F: sound/soc/fsl/imx-cdnhdmi.c
+F: sound/soc/fsl/imx-hdmi-dma.c
+F: sound/soc/fsl/imx-hdmi.c
+F: sound/soc/fsl/imx-hdmi.h
+
+audio/micfil
+M: Alison Wang <alison.wang@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+M: Viorel Suman <viorel.suman@nxp.com>
+F: sound/soc/fsl/fsl_micfil.c
+F: sound/soc/fsl/fsl_micfil.h
+
+audio/rpmsg
+M: Alison Wang <alison.wang@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+F: Documentation/devicetree/bindings/sound/fsl,rpmsg-i2s.txt
+F: Documentation/devicetree/bindings/sound/imx-audio-rpmsg.txt
+F: sound/soc/codecs/*rpmsg*
+
+audio/sai
+M: Alison Wang <alison.wang@nxp.com>
+M: Daniel Baluta <daniel.baluta@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+F: sound/soc/fsl/fsl_dsd.h
+F: sound/soc/fsl/fsl_sai.c
+F: sound/soc/fsl/fsl_sai.h
+
+audio/sof
+M: Alison Wang <alison.wang@nxp.com>
+M: Daniel Baluta <daniel.baluta@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+F: include/sound/sof.h
+F: sound/soc/sof/
+
+audio/spdif
+M: Alison Wang <alison.wang@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+M: Viorel Suman <viorel.suman@nxp.com>
+F: Documentation/devicetree/bindings/sound/fsl,spdif.txt
+F: sound/soc/fsl/fsl_spdif.c
+F: sound/soc/fsl/fsl_spdif.h
+F: sound/soc/fsl/imx-spdif.c
+
+audio/ssi
+M: Alison Wang <alison.wang@nxp.com>
+M: Shengjiu Wang <shengjiu.wang@nxp.com>
+F: sound/soc/fsl/fsl_ssi.c
+
+backlight
+M: Ying Liu <victor.liu@nxp.com>
+F: drivers/video/backlight/pwm_bl.c
+F: include/linux/pwm_backlight.h
+
+can
+M: Joakim Zhang <qiangqing.zhang@nxp.com>
+M: Pankaj Bansal <pankaj.bansal@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: Documentation/devicetree/bindings/net/can/fsl-flexcan.txt
+F: drivers/net/can/
+
+capture/csi2-mixel
+M: G.n. Zhou <guoniu.zhou@nxp.com>
+M: Robby Cai <robby.cai@nxp.com>
+F: Documentation/devicetree/bindings/media/imx8-mipi-csi.txt
+F: drivers/media/platform/imx8/mxc-mipi-csi2.h
+F: drivers/media/platform/imx8/mxc-mipi-csi2_yav.c
+F: drivers/staging/media/imx/imx8-mipi-csi2.c
+
+capture/csi2-samsung
+M: G.n. Zhou <guoniu.zhou@nxp.com>
+M: Robby Cai <robby.cai@nxp.com>
+F: drivers/media/platform/mxc/capture/mxc_mipi_csi.c
+F: drivers/staging/media/imx/imx8-mipi-csi2-sam.c
+
+capture/hdp
+M: Robby Cai <robby.cai@nxp.com>
+M: Sandor Yu <sandor.yu@nxp.com>
+
+capture/isi
+M: G.n. Zhou <guoniu.zhou@nxp.com>
+M: Sandor Yu <sandor.yu@nxp.com>
+M: Robby Cai <robby.cai@nxp.com>
+F: Documentation/devicetree/bindings/media/imx8-isi.txt
+F: drivers/staging/media/imx/*isi*
+
+capture/jpeg
+M: Robby Cai <robby.cai@nxp.com>
+M: Mirela Rabulea <mirela.rabulea@nxp.com>
+F: Documentation/devicetree/bindings/media/imx8-jpeg.txt
+F: drivers/media/platform/imx8/*jpeg*
+
+capture/max9286
+M: G.n. Zhou <guoniu.zhou@nxp.com>
+M: Robby Cai <robby.cai@nxp.com>
+F: drivers/staging/media/imx/gmsl-max9286.c
+
+capture/media
+M: G.n. Zhou <guoniu.zhou@nxp.com>
+M: Sandor Yu <sandor.yu@nxp.com>
+M: Robby Cai <robby.cai@nxp.com>
+M: Mirela Rabulea <mirela.rabulea@nxp.com>
+F: drivers/media/
+F: include/uapi/linux/videodev2.h
+
+capture/media-dev
+M: G.n. Zhou <guoniu.zhou@nxp.com>
+M: Sandor Yu <sandor.yu@nxp.com>
+M: Robby Cai <robby.cai@nxp.com>
+M: Mirela Rabulea <mirela.rabulea@nxp.com>
+F: Documentation/devicetree/bindings/media/imx8-media-dev.txt
+F: drivers/staging/media/imx/imx8-common.h
+F: drivers/staging/media/imx/imx8-media-dev.c
+
+capture/mxc
+M: Robby Cai <robby.cai@nxp.com>
+M: Sandor Yu <sandor.yu@nxp.com>
+F: drivers/media/platform/mxc/capture/
+F: drivers/mxc/mipi/
+F: include/linux/mipi_csi2.h
+F: include/uapi/linux/mxc_v4l2.h
+
+capture/ov5640
+M: G.n. Zhou <guoniu.zhou@nxp.com>
+M: Robby Cai <robby.cai@nxp.com>
+F: drivers/media/i2c/ov5640.c
+F: drivers/media/platform/mxc/capture/ov5640*
+
+capture/pi
+M: G.n. Zhou <guoniu.zhou@nxp.com>
+M: Robby Cai <robby.cai@nxp.com>
+F: Documentation/devicetree/bindings/media/imx8-parallel-csi.txt
+F: drivers/staging/media/imx/imx8-parallel-csi.c
+
+clock/imx
+M: Abel Vesa <abel.vesa@nxp.com>
+M: Andy Tang <andy.tang@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: Documentation/devicetree/bindings/clock/fsl,imx-blk-ctrl.yaml
+F: Documentation/devicetree/bindings/clock/imx*
+F: drivers/clk/imx/
+F: include/dt-bindings/clock/imx*
+
+clock/qoriq
+M: Abel Vesa <abel.vesa@nxp.com>
+M: Andy Tang <andy.tang@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: Documentation/devicetree/bindings/clock/qoriq-clock.txt
+F: drivers/clk/clk-qoriq.c
+
+clock/s32
+M: Abel Vesa <abel.vesa@nxp.com>
+M: Andy Tang <andy.tang@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: Documentation/devicetree/bindings/clock/s32v234-mc_cgm.txt
+F: Documentation/devicetree/bindings/clock/s32v234-mc_me.txt
+F: drivers/clk/s32/
+F: include/dt-bindings/clock/s32v234-clock.h
+
+config/arm
+M: Dong Aisheng <aisheng.dong@nxp.com>
+M: Li Yang <leoyang.li@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+F: arch/arm/configs/
+
+config/arm64
+M: Dong Aisheng <aisheng.dong@nxp.com>
+M: Li Yang <leoyang.li@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+F: arch/arm64/configs/
+
+config/powerpc
+M: Dong Aisheng <aisheng.dong@nxp.com>
+M: Li Yang <leoyang.li@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+F: arch/powerpc/configs/
+
+crypto/core
+M: Bogdan Folea <bogdan.folea@nxp.com>
+M: Valentin Ciocoi Radulescu <valentin.ciocoi@nxp.com>
+M: Horia Geanta <horia.geanta@nxp.com>
+F: arch/*/crypto/
+F: crypto/
+F: drivers/md/dm-crypt.c
+
+crypto/caam
+M: Bogdan Folea <bogdan.folea@nxp.com>
+M: Valentin Ciocoi Radulescu <valentin.ciocoi@nxp.com>
+M: Horia Geanta <horia.geanta@nxp.com>
+F: drivers/crypto/caam/
+F: include/uapi/linux/caam_keygen.h
+
+crypto/cse
+M: Bogdan Folea <bogdan.folea@nxp.com>
+M: Valentin Ciocoi Radulescu <valentin.ciocoi@nxp.com>
+M: Horia Geanta <horia.geanta@nxp.com>
+
+crypto/dcp
+M: Bogdan Folea <bogdan.folea@nxp.com>
+M: Valentin Ciocoi Radulescu <valentin.ciocoi@nxp.com>
+M: Horia Geanta <horia.geanta@nxp.com>
+F: drivers/crypto/mxs-dcp.c
+
+crypto/hse
+M: Bogdan Folea <bogdan.folea@nxp.com>
+M: Valentin Ciocoi Radulescu <valentin.ciocoi@nxp.com>
+M: Horia Geanta <horia.geanta@nxp.com>
+
+dce
+M: Roy Pledge <roy.pledge@nxp.com>
+
+display/bridge
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+M: Robert Chiras <robert.chiras@nxp.com>
+M: Fancy Fang <chen.fang@nxp.com>
+F: Documentation/devicetree/bindings/display/bridge/
+F: drivers/gpu/drm/bridge/
+F: include/drm/bridge/
+
+display/dcss
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Laurentiu Palcu <laurentiu.palcu@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+F: Documentation/devicetree/bindings/display/imx/nxp,imx8mq-dcss.yaml
+F: drivers/gpu/drm/imx/dcss/
+
+display/diu
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+
+display/dpu
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+F: Documentation/devicetree/bindings/display/imx/fsl-imx-drm.txt
+F: drivers/gpu/drm/imx/dpu/
+F: drivers/gpu/imx/dpu/
+F: include/video/dpu.h
+
+display/dpu-blit
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+M: Xianzhong Li <xianzhong.li@nxp.com>
+F: drivers/gpu/drm/imx/dpu/dpu-blit.c
+F: drivers/gpu/imx/dpu-blit/
+
+display/drm
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+M: Laurentiu Palcu <laurentiu.palcu@nxp.com>
+M: Fancy Fang <chen.fang@nxp.com>
+M: Robert Chiras <robert.chiras@nxp.com>
+M: Sandor Yu <sandor.yu@nxp.com>
+F: drivers/gpu/drm/
+F: include/drm/
+F: include/uapi/drm/
+F: include/uapi/linux/media-bus-format.h
+
+display/drm-core
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+M: Laurentiu Palcu <laurentiu.palcu@nxp.com>
+F: drivers/gpu/Makefile
+F: drivers/gpu/drm/imx/imx-drm-core.c
+F: drivers/gpu/drm/imx/imx-drm.h
+
+display/dsim
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Fancy Fang <chen.fang@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+F: drivers/gpu/drm/imx/sec_mipi_dphy_ln14lpp.h
+F: drivers/gpu/drm/imx/sec_mipi_dsim-imx.c
+F: drivers/gpu/drm/imx/sec_mipi_pll_1432x.h
+
+display/dw-hdmi
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Sandor Yu <Sandor.yu@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+F: drivers/gpu/drm/bridge/synopsys/
+F: drivers/gpu/drm/imx/dw_hdmi-imx.c
+F: drivers/gpu/drm/imx/imx8mp-hdmi-pavi.c
+F: drivers/gpu/drm/imx/imx8mp-hdmi-pavi.h
+F: include/drm/bridge/dw_hdmi.h
+
+display/fbdev
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+M: Sandor Yu <Sandor.yu@nxp.com>
+M: Fancy Fang <chen.fang@nxp.com>
+M: Robby Cai <robby.cai@nxp.com>
+F: drivers/video/fbdev/
+F: include/linux/fb.h
+F: include/linux/mipi_dsi.h
+F: include/linux/mipi_dsi_northwest.h
+F: include/linux/mipi_dsi_samsung.h
+F: include/linux/mxc_dcic.h
+F: include/linux/mxcfb_epdc.h
+F: include/uapi/linux/ipu.h
+F: include/uapi/linux/mxc_dcic.h
+F: include/uapi/linux/mxcfb.h
+F: include/uapi/linux/pxp_device.h
+F: include/uapi/linux/pxp_dma.h
+F: include/video/mxc_edid.h
+
+display/hdp
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Sandor Yu <Sandor.yu@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+F: drivers/gpu/drm/bridge/cadence/
+F: drivers/gpu/drm/imx/mhdp/
+F: drivers/gpu/drm/rockchip/
+F: include/drm/bridge/cdns-mhdp.h
+
+display/ipu
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+F: drivers/gpu/Makefile
+F: drivers/gpu/drm/imx/ipuv3/
+F: drivers/gpu/imx/ipu-v3/
+
+display/lcdif
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+M: Fancy Fang <chen.fang@nxp.com>
+M: Robert Chiras <robert.chiras@nxp.com>
+F: drivers/gpu/Makefile
+F: drivers/gpu/drm/imx/lcdif/
+F: drivers/gpu/drm/imx/lcdifv3/
+F: drivers/gpu/imx/lcdif/
+F: drivers/gpu/imx/lcdifv3/
+F: include/video/imx-lcdif.h
+F: include/video/imx-lcdifv3.h
+
+display/ldb
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+F: Documentation/devicetree/bindings/display/imx/ldb.txt
+F: drivers/gpu/drm/imx/*ldb*
+
+display/mali
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+
+display/mxsfb
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+M: Fancy Fang <chen.fang@nxp.com>
+M: Robert Chiras <robert.chiras@nxp.com>
+F: Documentation/devicetree/bindings/display/mxsfb.txt
+F: drivers/gpu/drm/mxsfb/
+
+display/nwl-dsi
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Robert Chiras <robert.chiras@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+F: drivers/gpu/drm/bridge/nwl-dsi.c
+F: drivers/phy/freescale/phy-fsl-imx8-mipi-dphy.c
+
+display/panel
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+F: Documentation/devicetree/bindings/display/panel/jdi,tx26d202vm0bwa.txt
+F: drivers/gpu/drm/panel/
+
+display/pc
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+M: Robert Chiras <robert.chiras@nxp.com>
+F: drivers/gpu/Makefile
+F: drivers/gpu/imx/imx8_pc.c
+F: include/video/imx8-pc.h
+
+display/prefetch
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+F: drivers/gpu/imx/imx8_dprc.c
+F: drivers/gpu/imx/imx8_prg.c
+F: include/video/imx8-prefetch.h
+
+display/lcdif-mux
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Wen He <wen.he_1@nxp.com>
+M: Ying Liu <victor.liu@nxp.com>
+F: drivers/gpu/drm/imx/lcdif-mux-display.c
+
+dma/caam
+M: Peng Ma <peng.ma@nxp.com>
+M: Robin Gong <yibin.gong@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+F: drivers/dma/caam_dma.c
+
+dma/edma
+M: Peng Ma <peng.ma@nxp.com>
+M: Robin Gong <yibin.gong@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+F: Documentation/devicetree/bindings/dma/fsl-edma-v3.txt
+F: Documentation/devicetree/bindings/dma/fsl-edma.txt
+F: Documentation/devicetree/bindings/dma/fsl-imx-dma.txt
+F: drivers/dma/fsl-edma*
+
+dma/mxsdma
+M: Peng Ma <peng.ma@nxp.com>
+M: Robin Gong <yibin.gong@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+F: drivers/dma/mxs-dma.c
+
+dma/pltmdma
+M: Peng Ma <peng.ma@nxp.com>
+M: Robin Gong <yibin.gong@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+F: drivers/dma/fsldma.*
+
+dma/qdma
+M: Peng Ma <peng.ma@nxp.com>
+M: Robin Gong <yibin.gong@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+F: drivers/dma/fsl-qdma.c
+
+dma/sdma
+M: Peng Ma <peng.ma@nxp.com>
+M: Robin Gong <yibin.gong@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+F: Documentation/devicetree/bindings/dma/fsl-imx-sdma.txt
+F: drivers/dma/imx-sdma.c
+F: include/linux/platform_data/dma-imx-sdma.h
+F: include/linux/platform_data/dma-imx.h
+
+dts/imx
+M: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
+M: Peng Fan <peng.fan@nxp.com>
+M: Abel Vesa <abel.vesa@nxp.com>
+M: Li Yang <leoyang.li@nxp.com>
+F: arch/arm/boot/dts/imx*
+F: arch/arm64/boot/dts/freescale/imx*
+
+dts/qoriq
+M: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
+M: Dong Aisheng <aisheng.dong@nxp.com>
+M: Li Yang <leoyang.li@nxp.com>
+F: Documentation/devicetree/bindings/arm/freescale/fsl,layerscape-dcfg.txt
+F: Documentation/devicetree/bindings/arm/fsl.yaml
+F: arch/arm/boot/dts/ls1021a-qds.dts
+F: arch/arm/boot/dts/ls1021a-twr.dts
+F: arch/arm/boot/dts/ls1021a.dtsi
+F: arch/arm64/boot/dts/freescale/fsl*
+F: arch/arm64/boot/dts/freescale/qoriq*
+F: arch/powerpc/boot/dts/
+
+dts/s32
+M: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
+M: Dong Aisheng <aisheng.dong@nxp.com>
+M: Li Yang <leoyang.li@nxp.com>
+F: arch/arm64/boot/dts/freescale/s32*
+
+edac
+M: Sherry Sun <sherry.sun@nxp.com>
+F: drivers/edac/
+F: include/linux/edac.h
+
+firmware
+M: Aisheng Dong <aisheng.dong@nxp.com>
+F: Documentation/devicetree/bindings/arm/freescale/fsl,seco_mu.yaml
+F: Documentation/devicetree/bindings/arm/freescale/fsl,scu*
+F: drivers/firmware/imx/
+F: include/linux/firmware/imx/
+
+flextimer
+M: Biwen Li <biwen.li@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: Documentation/devicetree/bindings/counter/ftm-quaddec.txt
+F: Documentation/devicetree/bindings/pwm/pwm-fsl-ftm.txt
+F: Documentation/devicetree/bindings/rtc/rtc-fsl-ftm-alarm.txt
+F: Documentation/devicetree/bindings/timer/fsl,ftm-timer.txt
+F: drivers/clocksource/timer-fsl-ftm.c
+F: drivers/rtc/rtc-fsl-ftm-alarm.c
+F: drivers/counter/ftm-quaddec.c
+F: drivers/pwm/pwm-fsl-ftm.c
+
+gpio
+M: Andy Duan <fugang.duan@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+M: Hui Song <hui.song_1@nxp.com>
+F: Documentation/devicetree/bindings/gpio/
+F: drivers/gpio/
+
+i2c
+M: Biwen Li <biwen.li@nxp.com>
+M: Clark Wang <xiaoning.wang@nxp.com>
+M: Dan Nica <dan.nica@nxp.com>
+F: Documentation/devicetree/bindings/i2c/
+F: drivers/i2c/
+
+input/keypad
+M: Haibo Chen <haibo.chen@nxp.com>
+M: Robin Gong <yibin.gong@nxp.com>
+F: Documentation/devicetree/bindings/input/
+F: drivers/input/keyboard/
+
+input/touch
+M: Haibo Chen <haibo.chen@nxp.com>
+F: Documentation/devicetree/bindings/input/touchscreen/
+F: drivers/input/touchscreen/
+
+irq
+M: Anson Huang <Anson.Huang@nxp.com>
+M: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
+M: Z.q. Hou <zhiqiang.hou@nxp.com>
+F: drivers/irqchip/
+
+jailhouse
+M: Diana Craciun <diana.craciun@nxp.com>
+M: Peng Fan <peng.fan@nxp.com>
+M: Catalin Dan Udma <catalin-dan.udma@nxp.com>
+F: drivers/net/ivshmem-net.c
+F: drivers/virt/jailhouse_dbgcon.c
+
+keys
+M: Bogdan Folea <bogdan.folea@nxp.com>
+M: Iuliana Prodan <iuliana.prodan@nxp.com>
+M: Udit Agarwal <udit.agarwal@nxp.com>
+F: Documentation/security/keys/
+F: include/keys/
+F: security/keys/
+
+kvm
+M: Diana Craciun <diana.craciun@nxp.com>
+M: Peng Fan <peng.fan@nxp.com>
+M: Catalin Dan Udma <catalin-dan.udma@nxp.com>
+F: arch/arm64/include/asm/kvm_mmu.h
+F: arch/arm64/kvm/
+
+mailbox
+M: Aisheng Dong <aisheng.dong@nxp.com>
+F: drivers/mailbox/imx-mailbox.c
+
+misc
+M: Li Yang <leoyang.li@nxp.com>
+F: Documentation/devicetree/bindings/mfd/fsl,imx-mix.yaml
+F: drivers/dma-buf/dma-buf.c
+F: drivers/mfd/
+F: drivers/nvmem/imx-ocotp.c
+F: drivers/staging/android/
+F: include/uapi/linux/dma-buf.h
+
+mxc/gpu
+M: Andy Tang <andy.tang@nxp.com>
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Eagle Zhou <eagle.zhou@nxp.com>
+M: Xianzhong Li <xianzhong.li@nxp.com>
+F: drivers/mxc/gpu-viv/
+
+mxc/hdmi
+M: Andy Tang <andy.tang@nxp.com>
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Eagle Zhou <eagle.zhou@nxp.com>
+F: drivers/mfd/mxc-hdmi-core.c
+F: drivers/mxc/hdmi-cec/
+F: include/linux/mfd/mxc-hdmi-core.h
+F: include/video/mxc_hdmi.h
+
+mxc/ipu
+M: Andy Tang <andy.tang@nxp.com>
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Eagle Zhou <eagle.zhou@nxp.com>
+F: drivers/media/platform/mxc/output/mxc_vout.c
+F: drivers/mxc/ipu3/
+F: include/linux/ipu-v3-pre.h
+F: include/linux/ipu-v3-prg.h
+F: include/linux/ipu-v3.h
+F: include/linux/ipu.h
+
+mxc/mlb
+M: Andy Tang <andy.tang@nxp.com>
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Eagle Zhou <eagle.zhou@nxp.com>
+F: Documentation/devicetree/bindings/mlb/mxc_mlb.txt
+F: drivers/mxc/mlb/
+F: include/linux/mxc_mlb.h
+F: include/uapi/linux/mxc_mlb.h
+
+mxc/sim
+M: Andy Tang <andy.tang@nxp.com>
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Eagle Zhou <eagle.zhou@nxp.com>
+M: Joakim Zhang <qiangqing.zhang@nxp.com>
+F: drivers/mxc/sim/
+F: include/linux/mxc_sim_interface.h
+F: include/uapi/linux/mxc_sim_interface.h
+
+mxc/vpu
+M: Andy Tang <andy.tang@nxp.com>
+M: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
+M: Eagle Zhou <eagle.zhou@nxp.com>
+M: Stefan Schwarz <stefan.schwarz@nxp.com>
+F: drivers/mxc/hantro*
+F: drivers/mxc/vpu*
+F: include/linux/hx280enc.h
+F: include/linux/mx8_mu.h
+F: include/linux/mxc_vpu.h
+F: include/uapi/linux/hantrodec.h
+F: include/uapi/linux/hx280enc.h
+F: include/uapi/linux/videodev2.h
+
+nand
+M: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
+M: Han Xu <han.xu@nxp.com>
+F: drivers/memory/fsl_ifc.c
+F: drivers/mtd/nand/raw/gpmi-nand/
+F: include/linux/fsl_ifc.h
+
+net/dpaa1
+M: Andy Duan <fugang.duan@nxp.com>
+M: Madalin Bucur <madalin.bucur@oss.nxp.com>
+M: Martin Gazda <martin.gazda@nxp.com>
+F: drivers/net/ethernet/freescale/sdk_dpaa/
+F: drivers/net/ethernet/freescale/sdk_fman/
+F: drivers/staging/fsl_qbman/
+F: include/linux/fsl_bman.h
+F: include/linux/fsl_qman.h
+F: include/linux/fsl_usdpaa.h
+F: include/linux/netdev_features.h
+F: include/uapi/linux/fmd/
+
+net/dpaa2
+M: Andy Duan <fugang.duan@nxp.com>
+M: Ioana Ciornei <ioana.ciornei@nxp.com>
+M: Madalin Bucur <madalin.bucur@oss.nxp.com>
+M: Martin Gazda <martin.gazda@nxp.com>
+F: Documentation/ABI/stable/sysfs-bus-fsl-mc
+F: drivers/bus/fsl-mc/
+F: drivers/net/ethernet/freescale/dpaa2/
+F: drivers/soc/fsl/dpio/
+F: drivers/staging/fsl-dpaa2/
+F: include/linux/fsl/mc.h
+F: include/soc/fsl/dpaa2-global.h
+F: include/soc/fsl/dpaa2-io.h
+F: include/uapi/linux/fsl_mc.h
+
+net/dwc_eqos
+M: Andy Duan <fugang.duan@nxp.com>
+M: Madalin Bucur <madalin.bucur@oss.nxp.com>
+M: Martin Gazda <martin.gazda@nxp.com>
+F: drivers/net/ethernet/stmicro/stmmac/
+
+net/enetc
+M: Andy Duan <fugang.duan@nxp.com>
+M: Claudiu Manoil <claudiu.manoil@nxp.com>
+M: Madalin Bucur <madalin.bucur@oss.nxp.com>
+M: Martin Gazda <martin.gazda@nxp.com>
+F: drivers/net/ethernet/freescale/enetc/
+
+net/etsec
+M: Andy Duan <fugang.duan@nxp.com>
+M: Claudiu Manoil <claudiu.manoil@nxp.com>
+M: Madalin Bucur <madalin.bucur@oss.nxp.com>
+M: Martin Gazda <martin.gazda@nxp.com>
+F: drivers/net/ethernet/freescale/gianfar*
+
+net/fec
+M: Andy Duan <fugang.duan@nxp.com>
+M: Madalin Bucur <madalin.bucur@oss.nxp.com>
+M: Martin Gazda <martin.gazda@nxp.com>
+F: Documentation/devicetree/bindings/net/fsl-fec.txt
+F: drivers/net/ethernet/freescale/fec.h
+F: drivers/net/ethernet/freescale/fec_main.c
+F: drivers/net/ethernet/freescale/fec_ptp.c
+
+net/fec-uio
+M: Apeksha Gupta <apeksha.gupta@nxp.com>
+M: Sachin Saxena <sachin.saxena@nxp.com>
+F: drivers/net/ethernet/freescale/fec_uio.c
+
+net/ls1028-switch
+M: Andy Duan <fugang.duan@nxp.com>
+M: Claudiu Manoil <claudiu.manoil@nxp.com>
+M: Madalin Bucur <madalin.bucur@oss.nxp.com>
+M: Martin Gazda <martin.gazda@nxp.com>
+F: drivers/net/ethernet/mscc/ocelot.c
+
+net/pfe
+M: Andy Duan <fugang.duan@nxp.com>
+M: Calvin Johnson <calvin.johnson@nxp.com>
+M: Madalin Bucur <madalin.bucur@oss.nxp.com>
+M: Martin Gazda <martin.gazda@nxp.com>
+F: Documentation/devicetree/bindings/net/fsl_ppfe/pfe.txt
+F: drivers/staging/fsl_ppfe/
+
+net/phy
+M: Andy Duan <fugang.duan@nxp.com>
+M: Florin Chiculita <florinlaurentiu.chiculita@nxp.com>
+M: Madalin Bucur <madalin.bucur@oss.nxp.com>
+M: Martin Gazda <martin.gazda@nxp.com>
+F: drivers/net/phy/
+F: include/linux/phy.h
+
+net/ptp
+M: Andy Duan <fugang.duan@nxp.com>
+M: Madalin Bucur <madalin.bucur@oss.nxp.com>
+M: Martin Gazda <martin.gazda@nxp.com>
+M: Yangbo Lu <yangbo.lu@nxp.com>
+F: drivers/ptp/
+
+net/tsn
+M: Andy Duan <fugang.duan@nxp.com>
+M: Claudiu Manoil <claudiu.manoil@nxp.com>
+M: Madalin Bucur <madalin.bucur@oss.nxp.com>
+M: Martin Gazda <martin.gazda@nxp.com>
+M: Po Liu <Po.Liu@nxp.com>
+F: include/net/tsn.h
+F: include/uapi/linux/tsn.h
+F: net/tsn/Kconfig
+F: net/tsn/Makefile
+F: net/tsn/genl_tsn.c
+
+net/tsn-switch
+M: Andy Duan <fugang.duan@nxp.com>
+M: Madalin Bucur <madalin.bucur@oss.nxp.com>
+M: Martin Gazda <martin.gazda@nxp.com>
+M: Xiaoliang Yang <xiaoliang.yang_1@nxp.com>
+
+nfc
+M: Biwen Li <biwen.li@nxp.com>
+
+pcie/core
+M: Richard Zhu <hongxing.zhu@nxp.com>
+M: Z.q. Hou <zhiqiang.hou@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+F: arch/arm64/kernel/pci.c
+F: drivers/misc/pci_endpoint_test.c
+F: drivers/pci/
+F: include/linux/pci.h
+
+pcie/dwc
+M: Richard Zhu <hongxing.zhu@nxp.com>
+M: Z.q. Hou <zhiqiang.hou@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+F: Documentation/devicetree/bindings/pci/fsl,imx6q-pcie.txt
+F: Documentation/devicetree/bindings/pci/layerscape-pci.txt
+F: drivers/pci/controller/dwc/
+F: include/dt-bindings/soc/imx8_hsio.h
+
+pcie/mobiveil
+M: Richard Zhu <hongxing.zhu@nxp.com>
+M: Z.q. Hou <zhiqiang.hou@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+F: Documentation/devicetree/bindings/pci/layerscape-pci.txt
+F: Documentation/devicetree/bindings/pci/layerscape-pcie-gen4.txt
+F: arch/arm/kernel/bios32.c
+F: arch/arm64/kernel/pci.c
+F: drivers/pci/controller/mobiveil/
+F: drivers/pci/pcie/portdrv_core.c
+
+perf
+M: Joakim Zhang <qiangqing.zhang@nxp.com>
+F: drivers/perf/
+F: tools/perf/
+
+phy
+M: Liu Ying <victor.liu@nxp.com>
+F: Documentation/devicetree/bindings/phy/
+F: drivers/phy/
+F: include/linux/phy/
+
+pinctrl
+M: Aisheng Dong <aisheng.dong@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: Documentation/devicetree/bindings/pinctrl/
+F: drivers/pinctrl/
+F: include/dt-bindings/pinctrl/
+
+pm/core
+M: Anson Huang <Anson.Huang@nxp.com>
+M: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
+M: Ran Wang <ran.wang_1@nxp.com>
+F: drivers/base/power/
+F: kernel/power/
+F: include/linux/pm.h
+F: include/linux/pm_*
+
+pm/imx
+M: Anson Huang <Anson.Huang@nxp.com>
+M: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
+M: Ran Wang <ran.wang_1@nxp.com>
+F: Documentation/devicetree/bindings/power/fsl,imx8m-genpd.txt
+F: drivers/char/imx_amp/
+F: drivers/cpufreq/
+F: drivers/power/supply/
+F: drivers/soc/imx/gpc.c
+F: drivers/soc/imx/imx8m_pm_domains.c
+F: include/linux/imx_sema4.h
+F: include/linux/power/sabresd_battery.h
+F: include/soc/imx/imx_sip.h
+
+pm/qoriq
+M: Anson Huang <Anson.Huang@nxp.com>
+M: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
+M: Ran Wang <ran.wang_1@nxp.com>
+F: Documentation/devicetree/bindings/soc/fsl/rcpm.txt
+F: drivers/soc/fsl/rcpm.c
+
+pxp
+M: Li Yang <leoyang.li@nxp.com>
+F: drivers/dma/pxp/
+F: drivers/media/platform/mxc/output/mxc_pxp_v4l2.c
+F: drivers/media/platform/mxc/output/mxc_pxp_v4l2.h
+F: include/linux/platform_data/dma-imx.h
+F: include/linux/pxp_device.h
+F: include/linux/pxp_dma.h
+
+qe
+M: Qiang Zhao <qiang.zhao@nxp.com>
+F: drivers/soc/fsl/qe/
+F: include/soc/fsl/*qe*.h
+F: include/soc/fsl/*ucc*.h
+F: drivers/net/ethernet/freescale/ucc_geth*
+F: drivers/net/wan/fsl_ucc_hdlc*
+F: drivers/tty/serial/ucc_uart.c
+
+regulator
+M: Robin Gong <yibin.gong@nxp.com>
+F: Documentation/devicetree/bindings/regulator/pfuze100.txt
+F: drivers/hwmon/max17135-hwmon.c
+F: drivers/mfd/max17135-core.c
+F: drivers/regulator/
+F: include/linux/mfd/max17135.h
+F: include/linux/pmic_status.h
+
+reset
+M: Anson Huang <Anson.Huang@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: Documentation/devicetree/bindings/reset/
+F: drivers/reset/
+F: include/dt-bindings/reset/
+
+rpmsg
+M: Richard Zhu <hongxing.zhu@nxp.com>
+F: Documentation/devicetree/bindings/soc/fsl/fsl,rpmsg.txt
+F: drivers/rpmsg/
+F: include/linux/imx_rpmsg.h
+
+rtc
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+M: Biwen Li <biwen.li@nxp.com>
+M: Anson Huang <anson.huang@nxp.com>
+F: drivers/rtc/
+
+sata
+M: Andy Tang <andy.tang@nxp.com>
+M: Richard Zhu <hongxing.zhu@nxp.com>
+F: drivers/ata/
+
+script
+M: Ting Liu <ting.liu@nxp.com>
+M: Aisheng Dong <aisheng.dong@nxp.com>
+M: Li Yang <leoyang.li@nxp.com>
+F: MAINTAINERS.NXP
+F: scripts/get_maintainer_nxp.sh
+
+sdhc
+M: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
+M: Haibo Chen <haibo.chen@nxp.com>
+M: Yangbo Lu <yangbo.lu@nxp.com>
+F: Documentation/devicetree/bindings/mmc/
+F: drivers/mmc/
+F: include/linux/mmc/
+
+sec
+M: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
+M: Silvano Di Ninno <silvano.dininno@nxp.com>
+M: Udit Agarwal <udit.agarwal@nxp.com>
+
+sensor
+M: Clark Wang <xiaoning.wang@nxp.com>
+F: drivers/hwmon/
+F: drivers/misc/fxas2100x.c
+F: drivers/misc/fxos8700.c
+F: include/uapi/linux/isl29023.h
+
+smmu
+M: Nipun Gupta <nipun.gupta@nxp.com>
+M: Peng Fan <peng.fan@nxp.com>
+F: drivers/iommu/
+
+spi/cspi
+M: Ashish Kumar <ashish.kumar@nxp.com>
+M: Han Xu <han.xu@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: drivers/spi/spi-imx.c
+
+spi/dspi
+M: Ashish Kumar <ashish.kumar@nxp.com>
+M: Han Xu <han.xu@nxp.com>
+M: Xiaowei Bao <xiaowei.bao@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: Documentation/devicetree/bindings/spi/spi-fsl-dspi.txt
+F: drivers/spi/spi-fsl-dspi.c
+
+spi/fspi
+M: Ashish Kumar <ashish.kumar@nxp.com>
+M: Han Xu <han.xu@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: Documentation/devicetree/bindings/spi/spi-nxp-fspi.txt
+F: drivers/spi/spi-nxp-fspi.c
+
+spi/lpspi
+M: Ashish Kumar <ashish.kumar@nxp.com>
+M: Han Xu <han.xu@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: Documentation/devicetree/bindings/spi/spi-fsl-lpspi.yaml
+F: drivers/spi/spi-fsl-lpspi.c
+
+spi/qspi
+M: Ashish Kumar <ashish.kumar@nxp.com>
+M: Han Xu <han.xu@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: Documentation/devicetree/bindings/spi/spi-fsl-qspi.txt
+F: drivers/spi/spi-fsl-qspi.c
+F: drivers/mtd/spi-nor/spansion.c
+
+thermal
+M: Andy Tang <andy.tang@nxp.com>
+M: Anson Huang <Anson.Huang@nxp.com>
+M: Ionut Vicovan <ionut.vicovan@nxp.com>
+F: drivers/thermal/
+F: include/linux/device_cooling.h
+
+timer
+M: Anson Huang <Anson.Huang@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: drivers/clocksource/
+
+uart
+M: Andy Duan <fugang.duan@nxp.com>
+M: Vabhav Sharma <vabhav.sharma@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: Documentation/devicetree/bindings/serial/fsl,s32-linflexuart.txt
+F: drivers/tty/serial/
+
+usb/cdns3
+M: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
+M: Peter Chen <peter.chen@nxp.com>
+M: Ran Wang <ran.wang_1@nxp.com>
+F: Documentation/devicetree/bindings/usb/cdns-usb3.txt
+F: drivers/usb/cdns3/
+
+usb/chipidea
+M: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
+M: Peter Chen <peter.chen@nxp.com>
+M: Ran Wang <ran.wang_1@nxp.com>
+F: Documentation/devicetree/bindings/usb/ci-hdrc-usb2.txt
+F: drivers/usb/chipidea/
+F: include/linux/usb/chipidea.h
+
+usb/chipidea-legacy
+M: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
+M: Peter Chen <peter.chen@nxp.com>
+M: Ran Wang <ran.wang_1@nxp.com>
+
+usb/core
+M: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
+M: Peter Chen <peter.chen@nxp.com>
+M: Ran Wang <ran.wang_1@nxp.com>
+F: Documentation/devicetree/bindings/usb/usb-xhci.txt
+F: drivers/usb/core/
+F: drivers/usb/host/
+F: include/linux/usb/
+
+usb/dwc3
+M: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
+M: Jun Li <jun.li@nxp.com>
+M: Peter Chen <peter.chen@nxp.com>
+M: Ran Wang <ran.wang_1@nxp.com>
+F: Documentation/devicetree/bindings/usb/dwc3.txt
+F: drivers/usb/dwc3/
+
+usb/phy
+M: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
+M: Peter Chen <peter.chen@nxp.com>
+M: Ran Wang <ran.wang_1@nxp.com>
+F: drivers/usb/phy/
+F: include/linux/usb/phy.h
+
+usb/typec
+M: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
+M: Jun Li <jun.li@nxp.com>
+M: Peter Chen <peter.chen@nxp.com>
+M: Ran Wang <ran.wang_1@nxp.com>
+F: Documentation/devicetree/bindings/usb/typec-switch-gpio.txt
+F: drivers/usb/typec/
+
+vfio
+M: Diana Craciun <diana.craciun@nxp.com>
+M: Peng Fan <peng.fan@nxp.com>
+M: Catalin Dan Udma <catalin-dan.udma@nxp.com>
+F: drivers/vfio/
+F: include/uapi/linux/vfio.h
+
+wdog
+M: Anson Huang <Anson.Huang@nxp.com>
+M: Qiang Zhao <qiang.zhao@nxp.com>
+M: Stefan-gabriel Mirea <stefan-gabriel.mirea@nxp.com>
+F: drivers/watchdog/
+
+wifi
+M: Andy Duan <fugang.duan@nxp.com>
+F: drivers/net/wireless/
+
+nvmem
+M: Peng Fan <peng.fan@nxp.com>
+F: drivers/nvmem/
+
+pwm
+M: Ying Liu <victor.liu@nxp.com>
+F: drivers/pwm/
+
+tee
+M: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
+M: Pankaj Gupta <pankaj.gupta@nxp.com>
+M: Silvano Di Ninno <silvano.dininno@nxp.com>
+F: drivers/tee/optee/
+
+xen
+M: Peng Fan <peng.fan@nxp.com>
+M: Catalin Dan Udma <catalin-dan.udma@nxp.com>
+F: Documentation/devicetree/bindings/i2c/i2c-xen.txt
+F: drivers/i2c/busses/xen*
+F: include/xen/interface/io/i2cif.h
+N: xen
+
+hotfix
+M: Aisheng Dong <aisheng.dong@nxp.com>
+M: Li Yang <leoyang.li@nxp.com>
diff --git a/Makefile b/Makefile
index dce02fbb7..e4ffbe5f5 100644
--- a/Makefile
+++ b/Makefile
@@ -426,9 +426,8 @@ KBUILD_HOSTLDLIBS   := $(HOST_LFS_LIBS) $(HOSTLDLIBS)
 
 # Make variables (CC, etc...)
 CPP		= $(CC) -E
-CCACHE          = ccache
 ifneq ($(LLVM),)
-CC		= $(CCACHE) clang
+CC		= clang
 LD		= ld.lld
 AR		= llvm-ar
 NM		= llvm-nm
@@ -437,7 +436,7 @@ OBJDUMP		= llvm-objdump
 READELF		= llvm-readelf
 STRIP		= llvm-strip
 else
-CC		= $(CCACHE) $(CROSS_COMPILE)gcc
+CC		= $(CROSS_COMPILE)gcc
 LD		= $(CROSS_COMPILE)ld
 AR		= $(CROSS_COMPILE)ar
 NM		= $(CROSS_COMPILE)nm
@@ -496,7 +495,6 @@ LINUXINCLUDE    := \
 KBUILD_AFLAGS   := -D__ASSEMBLY__ -fno-PIE
 KBUILD_CFLAGS   := -Wall -Wundef -Werror=strict-prototypes -Wno-trigraphs \
 		   -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE \
-		   -Werror=implicit-function-declaration -Werror=implicit-int \
 		   -Werror=return-type -Wno-format-security \
 		   -std=gnu89
 KBUILD_CPPFLAGS := -D__KERNEL__
@@ -945,7 +943,7 @@ KBUILD_CFLAGS   += $(call cc-option,-fconserve-stack)
 KBUILD_CFLAGS   += -Werror=date-time
 
 # enforce correct pointer usage
-KBUILD_CFLAGS   += $(call cc-option,-Werror=incompatible-pointer-types)
+# KBUILD_CFLAGS   += $(call cc-option,-Werror=incompatible-pointer-types)
 
 # Require designated initializers for all marked structures
 KBUILD_CFLAGS   += $(call cc-option,-Werror=designated-init)
diff --git a/scripts/gcc-plugins/Kconfig b/scripts/gcc-plugins/Kconfig
index ae19fb024..062617b90 100644
--- a/scripts/gcc-plugins/Kconfig
+++ b/scripts/gcc-plugins/Kconfig
@@ -10,7 +10,6 @@ menuconfig GCC_PLUGINS
 	depends on HAVE_GCC_PLUGINS
 	depends on CC_IS_GCC
 	depends on $(success,$(srctree)/scripts/gcc-plugin.sh $(CC))
-	default y
 	help
 	  GCC plugins are loadable modules that provide extra features to the
 	  compiler. They are useful for runtime instrumentation and static analysis.
diff --git a/scripts/get_maintainer_nxp.sh b/scripts/get_maintainer_nxp.sh
new file mode 100755
index 000000000..b58a0cbc2
--- /dev/null
+++ b/scripts/get_maintainer_nxp.sh
@@ -0,0 +1,112 @@
+#!/bin/bash
+
+V=${V:=false}
+scriptName=${0##*/}
+scriptDir="$(dirname $(readlink -f $0))"
+mfile=$scriptDir/../MAINTAINERS.NXP
+pl_script="./scripts/get_maintainer.pl"
+maillist="\
+linux-devel@linux.nxdi.nxp.com (Linux Factory Review List)
+lnxrevli@nxp.com (i.MX Review List)"
+
+usage() {
+cat <<EOF
+Wrapper script for kernel get_maintainer.pl
+
+Usage: $0 [options] patchfile
+       $0 [options] -f file|directory
+
+Options:
+  -s,--sendemail => send patch to maintainers for review
+    --from=<address> => email sender
+    --to=<address>,... => primary email recipient
+    --cc=<address>,... => additional email recipient
+    --confirm=<mode> => confirm just before sending (default: always)
+  --help => show this help information
+
+  Run "$pl_script -h" to get all other supported options.
+
+EOF
+}
+
+args="$@"
+# check -h and --help options
+if [ -n "`echo $args |awk '/(^| )(-h|--help)( |$)/'`" ];then
+    usage
+    exit
+fi
+
+# filter out --sendemail arguments
+sendemail=false
+if echo $args |grep -Eq '(^| )(\-s|\-\-sendemail)( |$)';then
+    sendemail=true
+    $V && echo "Sendemail: $sendemail"
+    args="`echo $args |sed -r 's,(^| )(-s|--sendemail)( |$), ,g'`"
+fi
+
+# filter out --from arguments
+email_from=""
+if echo $args |grep -Eq '\-\-from[ =]*[^ ]+';then
+    email_from="`echo $args |sed 's,--from[ =]*[^ ]*,\n&,g;s,[^\n]*\n\(--from[ =]*[^ ]*\)[^\n]*,\1 ,g;s/.$//'`"
+    $V && echo "From: `echo $email_from |sed 's,--from[ =]*,,g'`"
+    args="`echo $args |sed -e 's,--from[ =]*[^ ]*,,g'`"
+fi
+
+# filter out --to arguments
+email_to=""
+if echo $args |grep -Eq '\-\-to[ =]*[^ ]+';then
+    email_to="`echo $args |sed 's,--to[ =]*[^ ]*,\n&,g;s,[^\n]*\n\(--to[ =]*[^ ]*\)[^\n]*,\1 ,g;s/.$//'`"
+    $V && echo "To: `echo $email_to |sed 's,--to[ =]*,,g'`"
+    args="`echo $args |sed -e 's,--to[ =]*[^ ]*,,g'`"
+fi
+
+# filter out --cc arguments
+email_cc=""
+if echo $args |grep -Eq '\-\-cc[ =]*[^ ]+';then
+    email_cc="`echo $args |sed 's,--cc[ =]*[^ ]*,\n&,g;s,[^\n]*\n\(--cc[ =]*[^ ]*\)[^\n]*,\1 ,g;s/.$//'`"
+    $V && echo "Cc: `echo $email_cc |sed 's,--cc[ =]*,,g'`"
+    args="`echo $args |sed -e 's,--cc[ =]*[^ ]*,,g'`"
+fi
+
+# filter out --confirm arguments
+email_confirm="--confirm=always"
+if echo $args |grep -Eq '\-\-confirm[ =]*[^ ]+';then
+    email_confirm="`echo $args |sed 's,--confirm[ =]*[^ ]*,\n&,g;s,[^\n]*\n\(--confirm[ =]*[^ ]*\)[^\n]*,\1 ,g;s/.$//'`"
+    $V && echo "Confirm: `echo $email_confirm |sed 's,--confirm[ =]*,,g'`"
+    args="`echo $args |sed -e 's,--confirm[ =]*[^ ]*,,g'`"
+fi
+
+# remaining arguments to get_maintainer.pl
+$V && echo "Arguments: $args"
+
+# customized options to get_maintainer.pl
+opts="--n --rolestats"
+
+# filters for emails
+filter="/@/{/@[^@]*(nxp.com|nxp1.onmicrosoft.com)/I!d;}"
+
+perl $pl_script $opts --mpath $mfile $args |sed -r "$filter"
+echo "$maillist"
+echo
+
+if $sendemail;then
+   opts="--no-n --no-rolestats"
+   emails="`perl $pl_script $opts --mpath $mfile $args |sed -r "$filter"`"
+   emails="`echo $emails |sed -r 's,^[ \t]*,,;s,[ \t]*$,,;s/[ \t]+/,/g'`"
+   $V && echo "Maintainers: $emails"
+   # get patch files
+   for arg in $args;do
+       $V && echo $arg
+       if [ -e "$arg" ] && [ -z "`git ls-files $arg`" ];then
+           patches="$patches $arg"
+       fi
+   done
+   $V && echo "Patches: $patches"
+   if [ -z "$patches" ];then
+       echo "Error: no patch file found."
+       exit
+   fi
+   # display email sending command first in case users want to modify
+   echo git send-email --no-chain-reply-to --no-signed-off-by-cc --quiet --suppress-cc=all $email_confirm $email_from --to=$emails $email_to $email_cc --cc=linux-devel@linux.nxdi.nxp.com,lnxrevli@nxp.com $patches
+   git send-email --no-chain-reply-to --no-signed-off-by-cc --quiet --suppress-cc=all $email_confirm $email_from --to=$emails $email_to $email_cc --cc=linux-devel@linux.nxdi.nxp.com,lnxrevli@nxp.com $patches
+fi
diff --git a/scripts/headers_install.sh b/scripts/headers_install.sh
index dd554bd43..b9538827f 100755
--- a/scripts/headers_install.sh
+++ b/scripts/headers_install.sh
@@ -64,7 +64,7 @@ configs=$(sed -e '
 	d
 ' $OUTFILE)
 
-# The entries in the following list do not result in an error.
+# The entries in the following list are not warned.
 # Please do not add a new entry. This list is only for existing ones.
 # The list will be reduced gradually, and deleted eventually. (hopefully)
 #
@@ -93,19 +93,18 @@ include/uapi/linux/pktcdvd.h:CONFIG_CDROM_PKTCDVD_WCACHE
 
 for c in $configs
 do
-	leak_error=1
+	warn=1
 
 	for ignore in $config_leak_ignores
 	do
 		if echo "$INFILE:$c" | grep -q "$ignore$"; then
-			leak_error=
+			warn=
 			break
 		fi
 	done
 
-	if [ "$leak_error" = 1 ]; then
-		echo "error: $INFILE: leak $c to user-space" >&2
-		exit 1
+	if [ "$warn" = 1 ]; then
+		echo "warning: $INFILE: leak $c to user-space" >&2
 	fi
 done
 
diff --git a/tools/arch/x86/include/asm/cpufeatures.h b/tools/arch/x86/include/asm/cpufeatures.h
index b58730cc1..dad350d42 100644
--- a/tools/arch/x86/include/asm/cpufeatures.h
+++ b/tools/arch/x86/include/asm/cpufeatures.h
@@ -204,7 +204,7 @@
 #define X86_FEATURE_SME			( 7*32+10) /* AMD Secure Memory Encryption */
 #define X86_FEATURE_PTI			( 7*32+11) /* Kernel Page Table Isolation enabled */
 #define X86_FEATURE_RETPOLINE		( 7*32+12) /* "" Generic Retpoline mitigation for Spectre variant 2 */
-#define X86_FEATURE_RETPOLINE_LFENCE	( 7*32+13) /* "" Use LFENCEs for Spectre variant 2 */
+#define X86_FEATURE_RETPOLINE_AMD	( 7*32+13) /* "" AMD Retpoline mitigation for Spectre variant 2 */
 #define X86_FEATURE_INTEL_PPIN		( 7*32+14) /* Intel Processor Inventory Number */
 #define X86_FEATURE_CDP_L2		( 7*32+15) /* Code and Data Prioritization L2 */
 #define X86_FEATURE_MSR_SPEC_CTRL	( 7*32+16) /* "" MSR SPEC_CTRL is implemented */
diff --git a/tools/perf/arch/arm64/util/header.c b/tools/perf/arch/arm64/util/header.c
index d730666ab..ac887af0d 100644
--- a/tools/perf/arch/arm64/util/header.c
+++ b/tools/perf/arch/arm64/util/header.c
@@ -99,3 +99,31 @@ char *get_cpuid_str(struct perf_pmu *pmu)
 
 	return buf;
 }
+
+#define LEN	20
+
+int soc_version_check(const char *soc_name __maybe_unused)
+{
+	FILE *soc_fd;
+	char name[LEN];
+
+	soc_fd = fopen("/sys/devices/soc0/soc_id", "r");
+	if (!soc_fd) {
+		pr_debug("fopen failed for file /sys/devices/soc0/soc_id\n");
+		return false;
+	}
+
+	if (!fgets(name, LEN, soc_fd)) {
+		pr_debug("get soc name failed\n");
+		fclose(soc_fd);
+		return false;
+	}
+	fclose(soc_fd);
+
+	name[strlen(name) - 1] = '\0';
+
+	if (!strcmp(name, soc_name))
+		return false;
+
+	return true;
+}
diff --git a/tools/perf/pmu-events/arch/arm64/arm/cortex-a35/uncore-imx8dxl-ddr.json b/tools/perf/pmu-events/arch/arm64/arm/cortex-a35/uncore-imx8dxl-ddr.json
new file mode 100644
index 000000000..da7beb682
--- /dev/null
+++ b/tools/perf/pmu-events/arch/arm64/arm/cortex-a35/uncore-imx8dxl-ddr.json
@@ -0,0 +1,770 @@
+[
+    {
+	"BriefDescription": "bandwidth usage for lpddr4 evk board",
+	"MetricName": "imx8dxl_bandwidth_usage.lpddr4",
+	"MetricExpr": "(( imx8_ddr0@axid\\-read\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_channel\\=0x0@ + imx8_ddr0@axid\\-write\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_channel\\=0x0@ ) * 4 * 2 / duration_time) / (600 * 1000000 * 4 * 2)",
+	"ScaleUnit": "1e2%",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bandwidth usage for ddr3l evk board",
+	"MetricName": "imx8dxl_bandwidth_usage.ddr3l",
+	"MetricExpr": "(( imx8_ddr0@axid\\-read\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_channel\\=0x0@ + imx8_ddr0@axid\\-write\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_channel\\=0x0@ ) * 4 * 2 / duration_time) / (467 * 1000000 * 4 * 2)",
+	"ScaleUnit": "1e2%",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of all masters read from ddr",
+	"MetricName": "imx8dxl_ddr_read.all",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of all masters write to ddr",
+	"MetricName": "imx8dxl_ddr_write.all",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of scu cortex-m4 read from ddr",
+	"MetricName": "imx8dxl_ddr_read.scu_m4",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0000\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of scu cortex-m4 write to ddr",
+	"MetricName": "imx8dxl_ddr_write.scu_m4",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0000\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of dap read from ddr",
+	"MetricName": "imx8dxl_ddr_read.dap",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0010\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of dap write to ddr",
+	"MetricName": "imx8dxl_ddr_write.dap",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0010\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of atb read from ddr",
+	"MetricName": "imx8dxl_ddr_read.atb",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0018\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of atb write to ddr",
+	"MetricName": "imx8dxl_ddr_write.atb",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0018\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of caam read from ddr",
+	"MetricName": "imx8dxl_ddr_read.caam",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0f00\\,axi_id\\=0x0060\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of caam write to ddr",
+	"MetricName": "imx8dxl_ddr_write.caam",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0f00\\,axi_id\\=0x0060\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of test port read from ddr",
+	"MetricName": "imx8dxl_ddr_read.test_port",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0028\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of test port write to ddr",
+	"MetricName": "imx8dxl_ddr_write.test_port",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0028\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of general cortex-m4 read from ddr",
+	"MetricName": "imx8dxl_ddr_read.general_m4",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0001\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of general cortex-m4 write to ddr",
+	"MetricName": "imx8dxl_ddr_write.general_m4",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0001\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of edma0 read from ddr",
+	"MetricName": "imx8dxl_ddr_read.edma0",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0002\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of edma0 write to ddr",
+	"MetricName": "imx8dxl_ddr_write.edma0",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0002\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of edma2 read from ddr",
+	"MetricName": "imx8dxl_ddr_read.edma2",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x1812\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of edma2 write to ddr",
+	"MetricName": "imx8dxl_ddr_write.edma2",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x1812\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of edma3 read from ddr",
+	"MetricName": "imx8dxl_ddr_read.edma3",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x201a\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of edma3 write to ddr",
+	"MetricName": "imx8dxl_ddr_write.edma3",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x201a\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of lcdif regular channel read from ddr",
+	"MetricName": "imx8dxl_ddr_read.lcdif_regular",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x2802\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of lcdif regular channel write to ddr",
+	"MetricName": "imx8dxl_ddr_write.lcdif_regular",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x2802\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of lcdif alpha channel read from ddr",
+	"MetricName": "imx8dxl_ddr_read.lcdif_alpha",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x2842\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of lcdif alpha channel write to ddr",
+	"MetricName": "imx8dxl_ddr_write.lcdif_alpha",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x2842\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of raw nand (gpmi dma) read from ddr",
+	"MetricName": "imx8dxl_ddr_read.gpmi_dma",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0003\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of raw nand (gpmi dma) write to ddr",
+	"MetricName": "imx8dxl_ddr_write.gpmi_dma",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0003\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of raw nand (bch) read from ddr",
+	"MetricName": "imx8dxl_ddr_read.bch",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x000b\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of raw nand (bch) write to ddr",
+	"MetricName": "imx8dxl_ddr_write.bch",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x000b\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of enet rx read from ddr",
+	"MetricName": "imx8dxl_ddr_read.enet_rx",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0803\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of enet rx write to ddr",
+	"MetricName": "imx8dxl_ddr_write.enet_rx",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0803\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of enet tx read from ddr",
+	"MetricName": "imx8dxl_ddr_read.enet_tx",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x080b\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of enet tx write to ddr",
+	"MetricName": "imx8dxl_ddr_write.enet_tx",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x080b\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of eqis rx read from ddr",
+	"MetricName": "imx8dxl_ddr_read.eqis_rx",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0813\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of eqis rx write to ddr",
+	"MetricName": "imx8dxl_ddr_write.eqis_rx",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0813\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usb2.0 read from ddr",
+	"MetricName": "imx8dxl_ddr_read.usb",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x00b0\\,axi_id\\=0x040b\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usb2.0 write to ddr",
+	"MetricName": "imx8dxl_ddr_write.usb",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x00b0\\,axi_id\\=0x040b\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usdhc0 read from ddr",
+	"MetricName": "imx8dxl_ddr_read.usdhc0",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x001b\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usdhc0 write to ddr",
+	"MetricName": "imx8dxl_ddr_write.usdhc0",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x001b\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usdhc1 read from ddr",
+	"MetricName": "imx8dxl_ddr_read.usdhc1",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0023\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usdhc1 write to ddr",
+	"MetricName": "imx8dxl_ddr_write.usdhc1",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0023\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usdhc2 read from ddr",
+	"MetricName": "imx8dxl_ddr_read.usdhc2",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x002b\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usdhc2 write to ddr",
+	"MetricName": "imx8dxl_ddr_write.usdhc2",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x002b\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of hsio read from ddr",
+	"MetricName": "imx8dxl_ddr_read.hsio",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0xfff8\\,axi_id\\=0x0004\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of hsio write to ddr",
+	"MetricName": "imx8dxl_ddr_write.hsio",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0xfff8\\,axi_id\\=0x0004\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of lsio read from ddr",
+	"MetricName": "imx8dxl_ddr_read.lsio",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0xfff8\\,axi_id\\=0x0005\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of lsio write to ddr",
+	"MetricName": "imx8dxl_ddr_write.lsio",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0xfff8\\,axi_id\\=0x0005\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of cortex-a35 read from ddr",
+	"MetricName": "imx8dxl_ddr_read.a35",
+	"MetricExpr": "( imx8_ddr0@axid\\-read\\,axi_mask\\=0xfff8\\,axi_id\\=0x0006\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of cortex-a35 write to ddr",
+	"MetricName": "imx8dxl_ddr_write.a35",
+	"MetricExpr": "( imx8_ddr0@axid\\-write\\,axi_mask\\=0xfff8\\,axi_id\\=0x0006\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of scu cortex-m4 read from db",
+	"MetricName": "imx8dxl_db_read.scu_m4",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0000\\,axi_port\\=0x0\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of scu cortex-m4 write to db",
+	"MetricName": "imx8dxl_db_write.scu_m4",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0000\\,axi_port\\=0x0\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of dap read from db",
+	"MetricName": "imx8dxl_db_read.dap",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0002\\,axi_port\\=0x0\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of dap write to db",
+	"MetricName": "imx8dxl_db_write.dap",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0002\\,axi_port\\=0x0\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of atb read from db",
+	"MetricName": "imx8dxl_db_read.atb",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0003\\,axi_port\\=0x0\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of atb write to db",
+	"MetricName": "imx8dxl_db_write.atb",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0003\\,axi_port\\=0x0\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of caam read from db",
+	"MetricName": "imx8dxl_db_read.caam",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x01e0\\,axi_id\\=0x000c\\,axi_port\\=0x0\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of caam write to db",
+	"MetricName": "imx8dxl_db_write.caam",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x01e0\\,axi_id\\=0x000c\\,axi_port\\=0x0\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of test port read from db",
+	"MetricName": "imx8dxl_db_read.test_port",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0005\\,axi_port\\=0x0\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of test port write to db",
+	"MetricName": "imx8dxl_db_write.test_port",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0005\\,axi_port\\=0x0\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of general cortex-m4 read from db",
+	"MetricName": "imx8dxl_db_read.general_m4",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_port\\=0x1\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of general cortex-m4 write to db",
+	"MetricName": "imx8dxl_db_write.general_m4",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_port\\=0x1\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of edma0 read from db",
+	"MetricName": "imx8dxl_db_read.edma0",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0000\\,axi_port\\=0x2\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of edma0 write to db",
+	"MetricName": "imx8dxl_db_write.edma0",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0000\\,axi_port\\=0x2\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of edma2 read from db",
+	"MetricName": "imx8dxl_db_read.edma2",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0302\\,axi_port\\=0x2\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of edma2 write to db",
+	"MetricName": "imx8dxl_db_write.edma2",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0302\\,axi_port\\=0x2\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of edma3 read from db",
+	"MetricName": "imx8dxl_db_read.edma3",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0403\\,axi_port\\=0x2\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of edma3 write to db",
+	"MetricName": "imx8dxl_db_write.edma3",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0403\\,axi_port\\=0x2\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of lcdif regular channel read from db",
+	"MetricName": "imx8dxl_db_read.lcdif_regular",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0500\\,axi_port\\=0x2\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of lcdif regular channel write to db",
+	"MetricName": "imx8dxl_db_write.lcdif_regular",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0500\\,axi_port\\=0x2\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of lcdif alpha channel read from db",
+	"MetricName": "imx8dxl_db_read.lcdif_alpha",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0508\\,axi_port\\=0x2\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of lcdif alpha channel write to db",
+	"MetricName": "imx8dxl_db_write.lcdif_alpha",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0508\\,axi_port\\=0x2\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of raw nand (gpmi dma) read from db",
+	"MetricName": "imx8dxl_db_read.gpmi_dma",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0000\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of raw nand (gpmi dma) write to db",
+	"MetricName": "imx8dxl_db_write.gpmi_dma",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0000\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of raw nand (bch) read from db",
+	"MetricName": "imx8dxl_db_read.bch",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0001\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of raw nand (bch) write to db",
+	"MetricName": "imx8dxl_db_write.bch",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0001\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of enet rx read from db",
+	"MetricName": "imx8dxl_db_read.enet_rx",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0100\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of enet rx write to db",
+	"MetricName": "imx8dxl_db_write.enet_rx",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0100\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of enet tx read from db",
+	"MetricName": "imx8dxl_db_read.enet_tx",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0101\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of enet tx write to db",
+	"MetricName": "imx8dxl_db_write.enet_tx",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0101\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of eqis rx read from db",
+	"MetricName": "imx8dxl_db_read.eqis_rx",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0102\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of eqis rx write to db",
+	"MetricName": "imx8dxl_db_write.eqis_rx",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0102\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usb2.0 read from db",
+	"MetricName": "imx8dxl_db_read.usb",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0018\\,axi_id\\=0x0081\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usb2.0 write to db",
+	"MetricName": "imx8dxl_db_write.usb",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0018\\,axi_id\\=0x0081\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usdhc0 read from db",
+	"MetricName": "imx8dxl_db_read.usdhc0",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0003\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usdhc0 write to db",
+	"MetricName": "imx8dxl_db_write.usdhc0",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0003\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usdhc1 read from db",
+	"MetricName": "imx8dxl_db_read.usdhc1",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0004\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usdhc1 write to db",
+	"MetricName": "imx8dxl_db_write.usdhc1",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0004\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usdhc2 read from db",
+	"MetricName": "imx8dxl_db_read.usdhc2",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0005\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of usdhc2 write to db",
+	"MetricName": "imx8dxl_db_write.usdhc2",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0005\\,axi_port\\=0x3\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of hsio read from db",
+	"MetricName": "imx8dxl_db_read.hsio",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_port\\=0x4\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of hsio write to db",
+	"MetricName": "imx8dxl_db_write.hsio",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_port\\=0x4\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of lsio read from db",
+	"MetricName": "imx8dxl_db_read.lsio",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_port\\=0x5\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of lsio write to db",
+	"MetricName": "imx8dxl_db_write.lsio",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_port\\=0x5\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of cortex-a35 read from db",
+	"MetricName": "imx8dxl_db_read.a35",
+	"MetricExpr": "( imx8_db0@axid\\-read\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_port\\=0x6\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": " bytes of cortex-a35 write to db",
+	"MetricName": "imx8dxl_db_write.a35",
+	"MetricExpr": "( imx8_db0@axid\\-write\\,axi_mask\\=0xffff\\,axi_id\\=0x0000\\,axi_port\\=0x6\\,axi_channel\\=0x0@ ) * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8DXL",
+	"Unit": "imx8_ddr"
+    }
+]
diff --git a/tools/perf/pmu-events/arch/arm64/arm/cortex-a35/uncore-imx8qxp-ddr.json b/tools/perf/pmu-events/arch/arm64/arm/cortex-a35/uncore-imx8qxp-ddr.json
new file mode 100644
index 000000000..e3edd8bed
--- /dev/null
+++ b/tools/perf/pmu-events/arch/arm64/arm/cortex-a35/uncore-imx8qxp-ddr.json
@@ -0,0 +1,26 @@
+[
+    {
+	"BriefDescription": "bandwidth usage for lpddr4 mek board",
+	"MetricName": "imx8qxp_bandwidth_usage.lpddr4",
+	"MetricExpr": "(( imx8_ddr0@read\\-cycles@ + imx8_ddr0@write\\-cycles@ ) * 4 * 4 / duration_time) / (600 * 1000000 * 4 * 4)",
+	"ScaleUnit": "1e2%",
+	"SocName": "i.MX8QXP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes all masters read from ddr based on read-cycles event",
+	"MetricName": "imx8qxp_ddr_read.all",
+	"MetricExpr": "imx8_ddr0@read\\-cycles@ * 4 * 4",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8QXP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes all masters wirte to ddr based on write-cycles event",
+	"MetricName": "imx8qxp_ddr_write.all",
+	"MetricExpr": "imx8_ddr0@write\\-cycles@ * 4 * 4",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8QXP",
+	"Unit": "imx8_ddr"
+    }
+]
diff --git a/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8mm-ddr.json b/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8mm-ddr.json
new file mode 100644
index 000000000..eea2ce5c7
--- /dev/null
+++ b/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8mm-ddr.json
@@ -0,0 +1,34 @@
+[
+    {
+	"BriefDescription": "bandwidth usage for lpddr4 evk board",
+	"MetricName": "imx8mm_bandwidth_usage.lpddr4",
+	"MetricExpr": "(( imx8_ddr0@read\\-cycles@ + imx8_ddr0@write\\-cycles@ ) * 4 * 4 / duration_time) / (750 * 1000000 * 4 * 4)",
+	"ScaleUnit": "1e2%",
+	"SocName": "i.MX8MM",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bandwidth usage for ddr4 evk board",
+	"MetricName": "imx8mm_bandwidth_usage.ddr4",
+	"MetricExpr": "(( imx8_ddr0@read\\-cycles@ + imx8_ddr0@write\\-cycles@ ) * 4 * 4 / duration_time) / (600 * 1000000 * 4 * 4)",
+	"ScaleUnit": "1e2%",
+	"SocName": "i.MX8MM",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes all masters read from ddr based on read-cycles event",
+	"MetricName": "imx8mm_ddr_read.all",
+	"MetricExpr": "imx8_ddr0@read\\-cycles@ * 4 * 4",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MM",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes all masters wirte to ddr based on write-cycles event",
+	"MetricName": "imx8mm_ddr_write.all",
+	"MetricExpr": "imx8_ddr0@write\\-cycles@ * 4 * 4",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MM",
+	"Unit": "imx8_ddr"
+    }
+]
diff --git a/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8mn-ddr.json b/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8mn-ddr.json
new file mode 100644
index 000000000..195ad54e8
--- /dev/null
+++ b/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8mn-ddr.json
@@ -0,0 +1,34 @@
+[
+    {
+	"BriefDescription": "bandwidth usage for lpddr4 evk board",
+	"MetricName": "imx8mn_bandwidth_usage.lpddr4",
+	"MetricExpr": "(( imx8_ddr0@read\\-cycles@ + imx8_ddr0@write\\-cycles@ ) * 4 * 2 / duration_time) / (800 * 1000000 * 4 * 2)",
+	"ScaleUnit": "1e2%",
+	"SocName": "i.MX8MN",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bandwidth usage for ddr4 evk board",
+	"MetricName": "imx8mn_bandwidth_usage.ddr4",
+	"MetricExpr": "(( imx8_ddr0@read\\-cycles@ + imx8_ddr0@write\\-cycles@ ) * 4 * 2 / duration_time) / (600 * 1000000 * 4 * 2)",
+	"ScaleUnit": "1e2%",
+	"SocName": "i.MX8MN",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes all masters read from ddr based on read-cycles event",
+	"MetricName": "imx8mn_ddr_read.all",
+	"MetricExpr": "imx8_ddr0@read\\-cycles@ * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MN",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes all masters wirte to ddr based on write-cycles event",
+	"MetricName": "imx8mn_ddr_write.all",
+	"MetricExpr": "imx8_ddr0@write\\-cycles@ * 4 * 2",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MN",
+	"Unit": "imx8_ddr"
+    }
+]
diff --git a/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8mp-ddr.json b/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8mp-ddr.json
new file mode 100644
index 000000000..8d015b61b
--- /dev/null
+++ b/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8mp-ddr.json
@@ -0,0 +1,474 @@
+[
+    {
+	"BriefDescription": "bandwidth usage for lpddr4 evk board",
+	"MetricName": "imx8mp_bandwidth_usage.lpddr4",
+	"MetricExpr": "(( imx8_ddr0@axid\\-read\\,axi_mask\\=0xffff\\,axi_id\\=0x0000@ + imx8_ddr0@axid\\-write\\,axi_mask\\=0xffff\\,axi_id\\=0x0000@ ) / duration_time) / (1000 * 1000000 * 4 * 4)",
+	"ScaleUnit": "1e2%",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of all masters read from ddr",
+	"MetricName": "imx8mp_ddr_read.all",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0xffff\\,axi_id\\=0x0000@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of all masters write to ddr",
+	"MetricName": "imx8mp_ddr_write.all",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0xffff\\,axi_id\\=0x0000@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of a53 core read from ddr",
+	"MetricName": "imx8mp_ddr_read.a53",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0000@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of a53 core write to ddr",
+	"MetricName": "imx8mp_ddr_write.a53",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0000@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of supermix(m7) core read from ddr",
+	"MetricName": "imx8mp_ddr_read.supermix",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x000f\\,axi_id\\=0x0020@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of supermix(m7) write to ddr",
+	"MetricName": "imx8mp_ddr_write.supermix",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x000f\\,axi_id\\=0x0020@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of gpu 3d read from ddr",
+	"MetricName": "imx8mp_ddr_read.3d",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0070@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of gpu 3d write to ddr",
+	"MetricName": "imx8mp_ddr_write.3d",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0070@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of gpu 2d read from ddr",
+	"MetricName": "imx8mp_ddr_read.2d",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0071@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of gpu 2d write to ddr",
+	"MetricName": "imx8mp_ddr_write.2d",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0071@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display lcdif1 read from ddr",
+	"MetricName": "imx8mp_ddr_read.lcdif1",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0068@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display lcdif1 write to ddr",
+	"MetricName": "imx8mp_ddr_write.lcdif1",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0068@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display lcdif2 read from ddr",
+	"MetricName": "imx8mp_ddr_read.lcdif2",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0069@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display lcdif2 write to ddr",
+	"MetricName": "imx8mp_ddr_write.lcdif2",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0069@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display isi1 read from ddr",
+	"MetricName": "imx8mp_ddr_read.isi1",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x006a@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display isi1 write to ddr",
+	"MetricName": "imx8mp_ddr_write.isi1",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x006a@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display isi2 read from ddr",
+	"MetricName": "imx8mp_ddr_read.isi2",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x006b@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display isi2 write to ddr",
+	"MetricName": "imx8mp_ddr_write.isi2",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x006b@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display isi3 read from ddr",
+	"MetricName": "imx8mp_ddr_read.isi3",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x006c@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display isi3 write to ddr",
+	"MetricName": "imx8mp_ddr_write.isi3",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x006c@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display isp1 read from ddr",
+	"MetricName": "imx8mp_ddr_read.isp1",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x006d@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display isp1 write to ddr",
+	"MetricName": "imx8mp_ddr_write.isp1",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x006d@",
+	"MetricGroup": "imx8_ddr_DDR_MON",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display isp2 read from ddr",
+	"MetricName": "imx8mp_ddr_read.isp2",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x006e@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display isp2 write to ddr",
+	"MetricName": "imx8mp_ddr_write.isp2",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x006e@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display dewarp read from ddr",
+	"MetricName": "imx8mp_ddr_read.dewarp",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x006f@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of display dewarp write to ddr",
+	"MetricName": "imx8mp_ddr_write.dewarp",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x006f@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of vpu1 read from ddr",
+	"MetricName": "imx8mp_ddr_read.vpu1",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x007c@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of vpu1 write to ddr",
+	"MetricName": "imx8mp_ddr_write.vpu1",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x007c@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of vpu2 read from ddr",
+	"MetricName": "imx8mp_ddr_read.vpu2",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x007d@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of vpu2 write to ddr",
+	"MetricName": "imx8mp_ddr_write.vpu2",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x007d@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of vpu3 read from ddr",
+	"MetricName": "imx8mp_ddr_read.vpu3",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x007e@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of vpu3 write to ddr",
+	"MetricName": "imx8mp_ddr_write.vpu3",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x007e@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of npu read from ddr",
+	"MetricName": "imx8mp_ddr_read.npu",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0073@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of npu write to ddr",
+	"MetricName": "imx8mp_ddr_write.npu",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0073@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of hsio usb1 read from ddr",
+	"MetricName": "imx8mp_ddr_read.usb1",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0078@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of hsio usb1 write to ddr",
+	"MetricName": "imx8mp_ddr_write.usb1",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0078@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of hsio usb2 read from ddr",
+	"MetricName": "imx8mp_ddr_read.usb2",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0079@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of hsio usb2 write to ddr",
+	"MetricName": "imx8mp_ddr_write.usb2",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0079@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of hsio pci read from ddr",
+	"MetricName": "imx8mp_ddr_read.pci",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x007a@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of hsio pci write to ddr",
+	"MetricName": "imx8mp_ddr_write.pci",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x007a@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of hdmi_tx hrv_mwr read from ddr",
+	"MetricName": "imx8mp_ddr_read.hdmi_hrv_mwr",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0074@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of hdmi_tx hrv_mwr write to ddr",
+	"MetricName": "imx8mp_ddr_write.hdmi_hrv_mwr",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0074@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of hdmi_tx lcdif read from ddr",
+	"MetricName": "imx8mp_ddr_read.hdmi_lcdif",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0075@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of hdmi_tx lcdif write to ddr",
+	"MetricName": "imx8mp_ddr_write.hdmi_lcdif",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0075@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of hdmi_tx tx_hdcp read from ddr",
+	"MetricName": "imx8mp_ddr_read.hdmi_hdcp",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0076@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of hdmi_tx tx_hdcp write to ddr",
+	"MetricName": "imx8mp_ddr_write.hdmi_hdcp",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0076@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of audio dsp read from ddr",
+	"MetricName": "imx8mp_ddr_read.audio_dsp",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0041@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of audio dsp write to ddr",
+	"MetricName": "imx8mp_ddr_write.audio_dsp",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0041@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of audio sdma2_per read from ddr",
+	"MetricName": "imx8mp_ddr_read.audio_sdma2_per",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0062@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of audio sdma2_per write to ddr",
+	"MetricName": "imx8mp_ddr_write.audio_sdma2_per",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0062@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of audio sdma2_burst read from ddr",
+	"MetricName": "imx8mp_ddr_read.audio_sdma2_burst",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0063@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of audio sdma2_burst write to ddr",
+	"MetricName": "imx8mp_ddr_write.audio_sdma2_burst",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0063@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of audio sdma3_per read from ddr",
+	"MetricName": "imx8mp_ddr_read.audio_sdma3_per",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0064@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of audio sdma3_per write to ddr",
+	"MetricName": "imx8mp_ddr_write.audio_sdma3_per",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0064@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of audio sdma3_burst read from ddr",
+	"MetricName": "imx8mp_ddr_read.audio_sdma3_burst",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0065@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of audio sdma3_burst write to ddr",
+	"MetricName": "imx8mp_ddr_write.audio_sdma3_burst",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0065@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of audio sdma_pif read from ddr",
+	"MetricName": "imx8mp_ddr_read.audio_sdma_pif",
+	"MetricExpr": "imx8_ddr0@axid\\-read\\,axi_mask\\=0x0000\\,axi_id\\=0x0066@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes of audio sdma_pif write to ddr",
+	"MetricName": "imx8mp_ddr_write.audio_sdma_pif",
+	"MetricExpr": "imx8_ddr0@axid\\-write\\,axi_mask\\=0x0000\\,axi_id\\=0x0066@",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MP",
+	"Unit": "imx8_ddr"
+    }
+]
diff --git a/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8mq-ddr.json b/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8mq-ddr.json
new file mode 100644
index 000000000..7e2b8ce0e
--- /dev/null
+++ b/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8mq-ddr.json
@@ -0,0 +1,26 @@
+[
+    {
+	"BriefDescription": "bandwidth usage for lpddr4 evk board",
+	"MetricName": "imx8mq_bandwidth_usage.lpddr4",
+	"MetricExpr": "(( imx8_ddr0@read\\-cycles@ + imx8_ddr0@write\\-cycles@ ) * 4 * 4 / duration_time) / (800 * 1000000 * 4 * 4)",
+	"ScaleUnit": "1e2%",
+	"SocName": "i.MX8MQ",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes all masters read from ddr based on read-cycles event",
+	"MetricName": "imx8mq_ddr_read.all",
+	"MetricExpr": "imx8_ddr0@read\\-cycles@ * 4 * 4",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MQ",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes all masters wirte to ddr based on write-cycles event",
+	"MetricName": "imx8mq_ddr_write.all",
+	"MetricExpr": "imx8_ddr0@write\\-cycles@ * 4 * 4",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8MQ",
+	"Unit": "imx8_ddr"
+    }
+]
diff --git a/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8qm-ddr.json b/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8qm-ddr.json
new file mode 100644
index 000000000..ae6864867
--- /dev/null
+++ b/tools/perf/pmu-events/arch/arm64/arm/cortex-a53/uncore-imx8qm-ddr.json
@@ -0,0 +1,26 @@
+[
+    {
+	"BriefDescription": "bandwidth usage for lpddr4 mek board",
+	"MetricName": "imx8qm_bandwidth_usage.lpddr4",
+	"MetricExpr": "(( imx8_ddr0@read\\-cycles@ + imx8_ddr0@write\\-cycles@ + imx8_ddr1@read\\-cycles@ + imx8_ddr1@write\\-cycles@ ) * 4 * 4 / duration_time) / (800 * 1000000 * 4 * 4)",
+	"ScaleUnit": "1e2%",
+	"SocName": "i.MX8QM",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes all masters read from ddr based on read-cycles event",
+	"MetricName": "imx8qm_ddr_read.all",
+	"MetricExpr": "( imx8_ddr0@read\\-cycles@ + imx8_ddr1@read\\-cycles@ ) * 4 * 4",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8QM",
+	"Unit": "imx8_ddr"
+    },
+    {
+	"BriefDescription": "bytes all masters wirte to ddr based on write-cycles event",
+	"MetricName": "imx8qm_ddr_write.all",
+	"MetricExpr": "( imx8_ddr0@write\\-cycles@ + imx8_ddr1@write\\-cycles@ ) * 4 * 4",
+	"ScaleUnit": "9.765625e-4KB",
+	"SocName": "i.MX8QM",
+	"Unit": "imx8_ddr"
+    }
+]
diff --git a/tools/perf/pmu-events/arch/arm64/mapfile.csv b/tools/perf/pmu-events/arch/arm64/mapfile.csv
index 0d609149b..71f7a900f 100644
--- a/tools/perf/pmu-events/arch/arm64/mapfile.csv
+++ b/tools/perf/pmu-events/arch/arm64/mapfile.csv
@@ -13,6 +13,7 @@
 #
 #Family-model,Version,Filename,EventType
 0x00000000410fd030,v1,arm/cortex-a53,core
+0x00000000410fd040,v1,arm/cortex-a35,core
 0x00000000420f1000,v1,arm/cortex-a53,core
 0x00000000410fd070,v1,arm/cortex-a57-a72,core
 0x00000000410fd080,v1,arm/cortex-a57-a72,core
diff --git a/tools/perf/pmu-events/jevents.c b/tools/perf/pmu-events/jevents.c
index c679a79ae..f18b08fc3 100644
--- a/tools/perf/pmu-events/jevents.c
+++ b/tools/perf/pmu-events/jevents.c
@@ -61,6 +61,7 @@ struct json_event {
 	char *pmu;
 	char *unit;
 	char *perpkg;
+	char *socname;
 	char *aggr_mode;
 	char *metric_expr;
 	char *metric_name;
@@ -258,6 +259,7 @@ static struct map {
 	{ "SBO", "uncore_sbox" },
 	{ "iMPH-U", "uncore_arb" },
 	{ "CPU-M-CF", "cpum_cf" },
+	{ "imx8_ddr", "imx8_ddr"},
 	{ "CPU-M-SF", "cpum_sf" },
 	{ "UPI LL", "uncore_upi" },
 	{ "hisi_sccl,ddrc", "hisi_sccl,ddrc" },
@@ -369,6 +371,8 @@ static int print_events_table_entry(void *data, struct json_event *je)
 		fprintf(outfp, "\t.unit = \"%s\",\n", je->unit);
 	if (je->perpkg)
 		fprintf(outfp, "\t.perpkg = \"%s\",\n", je->perpkg);
+	if (je->socname)
+		fprintf(outfp, "\t.socname = \"%s\",\n", je->socname);
 	if (je->aggr_mode)
 		fprintf(outfp, "\t.aggr_mode = \"%d\",\n", convert(je->aggr_mode));
 	if (je->metric_expr)
@@ -395,6 +399,7 @@ struct event_struct {
 	char *pmu;
 	char *unit;
 	char *perpkg;
+	char *socname;
 	char *aggr_mode;
 	char *metric_expr;
 	char *metric_name;
@@ -425,6 +430,7 @@ struct event_struct {
 	op(pmu);						\
 	op(unit);						\
 	op(perpkg);						\
+	op(socname);						\
 	op(aggr_mode);						\
 	op(metric_expr);					\
 	op(metric_name);					\
@@ -626,6 +632,8 @@ static int json_events(const char *fn,
 				addfield(map, &je.unit, "", "", val);
 			} else if (json_streq(map, field, "PerPkg")) {
 				addfield(map, &je.perpkg, "", "", val);
+			} else if (json_streq(map, field, "SocName")) {
+				addfield(map, &je.socname, "", "", val);
 			} else if (json_streq(map, field, "AggregationMode")) {
 				addfield(map, &je.aggr_mode, "", "", val);
 			} else if (json_streq(map, field, "Deprecated")) {
@@ -688,6 +696,7 @@ static int json_events(const char *fn,
 		free(je.pmu);
 		free(filter);
 		free(je.perpkg);
+		free(je.socname);
 		free(je.aggr_mode);
 		free(je.deprecated);
 		free(je.unit);
diff --git a/tools/perf/pmu-events/pmu-events.h b/tools/perf/pmu-events/pmu-events.h
index 7da1a3743..89931de5f 100644
--- a/tools/perf/pmu-events/pmu-events.h
+++ b/tools/perf/pmu-events/pmu-events.h
@@ -19,6 +19,7 @@ struct pmu_event {
 	const char *pmu;
 	const char *unit;
 	const char *perpkg;
+	const char *socname;
 	const char *aggr_mode;
 	const char *metric_expr;
 	const char *metric_name;
diff --git a/tools/perf/util/header.c b/tools/perf/util/header.c
index be850e9f8..141131a03 100644
--- a/tools/perf/util/header.c
+++ b/tools/perf/util/header.c
@@ -844,6 +844,15 @@ int __weak strcmp_cpuid_str(const char *mapcpuid, const char *cpuid)
 	return 1;
 }
 
+/*
+ * default soc_version_check(): nothing gets recorded
+ * actual implementation must be in arch/$(SRCARCH)/util/header.c
+ */
+int __weak soc_version_check(const char *soc_name __maybe_unused)
+{
+	return -1;
+}
+
 /*
  * default get_cpuid(): nothing gets recorded
  * actual implementation must be in arch/$(SRCARCH)/util/header.c
diff --git a/tools/perf/util/header.h b/tools/perf/util/header.h
index 2aca71763..5691073fe 100644
--- a/tools/perf/util/header.h
+++ b/tools/perf/util/header.h
@@ -163,4 +163,6 @@ int get_cpuid(char *buffer, size_t sz);
 
 char *get_cpuid_str(struct perf_pmu *pmu __maybe_unused);
 int strcmp_cpuid_str(const char *s1, const char *s2);
+
+int soc_version_check(const char *soc_name __maybe_unused);
 #endif /* __PERF_HEADER_H */
diff --git a/tools/perf/util/metricgroup.c b/tools/perf/util/metricgroup.c
index 060454a17..1f12fe301 100644
--- a/tools/perf/util/metricgroup.c
+++ b/tools/perf/util/metricgroup.c
@@ -13,6 +13,7 @@
 #include "pmu.h"
 #include "expr.h"
 #include "rblist.h"
+#include "header.h"
 #include <string.h>
 #include <errno.h>
 #include "strlist.h"
@@ -518,6 +519,8 @@ void metricgroup__print(bool metrics, bool metricgroups, char *filter,
 		const char *g;
 		pe = &map->table[i];
 
+		if (pe->socname && soc_version_check(pe->socname))
+			continue;
 		if (!pe->name && !pe->metric_group && !pe->metric_name)
 			break;
 		if (!pe->metric_expr)
diff --git a/tools/perf/util/pmu.c b/tools/perf/util/pmu.c
index d41caeb35..289c7af53 100644
--- a/tools/perf/util/pmu.c
+++ b/tools/perf/util/pmu.c
@@ -664,6 +664,15 @@ static char *perf_pmu__getcpuid(struct perf_pmu *pmu)
 		cpuid = strdup(cpuid);
 	if (!cpuid)
 		cpuid = get_cpuid_str(pmu);
+	if (!cpuid && !pmu) {
+		cpuid = malloc(1024);
+		if (!cpuid)
+			return NULL;
+		if (get_cpuid(cpuid, 1024)) {
+			free(cpuid);
+			return NULL;
+		}
+	}
 	if (!cpuid)
 		return NULL;
 
diff --git a/tools/virtio/Makefile b/tools/virtio/Makefile
index 0d7bbe493..9a1a2f38a 100644
--- a/tools/virtio/Makefile
+++ b/tools/virtio/Makefile
@@ -1,8 +1,10 @@
 # SPDX-License-Identifier: GPL-2.0
-all: test mod
+all: test mod virtio-ivshmem-block virtio-ivshmem-console
 test: virtio_test vringh_test
 virtio_test: virtio_ring.o virtio_test.o
 vringh_test: vringh_test.o vringh.o virtio_ring.o
+virtio-ivshmem-block: virtio-ivshmem-block.o
+virtio-ivshmem-console: virtio-ivshmem-console.o
 
 CFLAGS += -g -O2 -Werror -Wno-maybe-uninitialized -Wall -I. -I../include/ -I ../../usr/include/ -Wno-pointer-sign -fno-strict-overflow -fno-strict-aliasing -fno-common -MMD -U_FORTIFY_SOURCE -include ../../include/linux/kconfig.h
 LDFLAGS += -lpthread
@@ -38,5 +40,6 @@ oot-clean: OOT_BUILD+=clean
 .PHONY: all test mod clean vhost oot oot-clean oot-build
 clean:
 	${RM} *.o vringh_test virtio_test vhost_test/*.o vhost_test/.*.cmd \
-              vhost_test/Module.symvers vhost_test/modules.order *.d
+              vhost_test/Module.symvers vhost_test/modules.order *.d \
+              virtio-ivshmem-block virtio-ivshmem-console
 -include *.d
diff --git a/tools/virtio/asm/barrier.h b/tools/virtio/asm/barrier.h
index 04d563fc9..468435ed6 100644
--- a/tools/virtio/asm/barrier.h
+++ b/tools/virtio/asm/barrier.h
@@ -16,6 +16,16 @@
 # define mb() abort()
 # define dma_rmb() abort()
 # define dma_wmb() abort()
+#elif defined(__aarch64__)
+#define dmb(opt) asm volatile("dmb " #opt : : : "memory")
+#define virt_mb() __sync_synchronize()
+#define virt_rmb() dmb(ishld)
+#define virt_wmb() dmb(ishst)
+#define virt_store_mb(var, value)  do { WRITE_ONCE(var, value); dmb(ish); } while (0)
+/* Weak barriers should be used. If not - it's a bug */
+# define mb() abort()
+# define dma_rmb() abort()
+# define dma_wmb() abort()
 #else
 #error Please fill in barrier macros
 #endif
diff --git a/tools/virtio/virtio-ivshmem-block.c b/tools/virtio/virtio-ivshmem-block.c
new file mode 100644
index 000000000..c97aa5076
--- /dev/null
+++ b/tools/virtio/virtio-ivshmem-block.c
@@ -0,0 +1,357 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Virtio block over uio_ivshmem back-end device
+ *
+ * Copyright (c) Siemens AG, 2019
+ */
+
+/*
+ * HACK warnings:
+ *  - little-endian hosts only
+ *  - no proper input validation (specifically addresses)
+ *  - may miss a couple of barriers
+ *  - ignores a couple of mandatory properties, e.g. notification control
+ *  - could implement some optional block features
+ *  - might eat your data
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <error.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <linux/virtio_blk.h>
+#include <linux/virtio_ring.h>
+
+#ifndef VIRTIO_F_ORDER_PLATFORM
+#define VIRTIO_F_ORDER_PLATFORM		36
+#endif
+
+struct ivshm_regs {
+	uint32_t id;
+	uint32_t max_peers;
+	uint32_t int_control;
+	uint32_t doorbell;
+	uint32_t state;
+};
+
+#define VIRTIO_STATE_RESET		0
+#define VIRTIO_STATE_READY		1
+
+struct virtio_queue_config {
+	uint16_t size;
+	uint16_t device_vector;
+	uint16_t driver_vector;
+	uint16_t enable;
+	uint64_t desc;
+	uint64_t driver;
+	uint64_t device;
+};
+
+struct virtio_ivshmem_block {
+	uint32_t revision;
+	uint32_t size;
+
+	uint32_t write_transaction;
+
+	uint32_t device_features;
+	uint32_t device_features_sel;
+	uint32_t driver_features;
+	uint32_t driver_features_sel;
+
+	uint32_t queue_sel;
+	struct virtio_queue_config queue_config;
+
+	uint8_t config_event;
+	uint8_t queue_event;
+	uint8_t __reserved[2];
+	uint32_t device_status;
+
+	uint32_t config_generation;
+
+	struct virtio_blk_config config;
+};
+
+#define VI_REG_OFFSET(reg) \
+	__builtin_offsetof(struct virtio_ivshmem_block, reg)
+
+static struct ivshm_regs *regs;
+static int uio_fd, image_fd;
+static struct stat image_stat;
+static struct virtio_ivshmem_block *vb;
+static struct vring vring;
+static uint16_t next_idx;
+static void *shmem;
+static uint32_t peer_id;
+
+static inline uint32_t mmio_read32(void *address)
+{
+	return *(volatile uint32_t *)address;
+}
+
+static inline void mmio_write32(void *address, uint32_t value)
+{
+	*(volatile uint32_t *)address = value;
+}
+
+static void wait_for_interrupt(struct ivshm_regs *regs)
+{
+	uint32_t dummy;
+
+	if (read(uio_fd, &dummy, 4) < 0)
+		error(1, errno, "UIO read failed");
+	mmio_write32(&regs->int_control, 1);
+}
+
+static int process_queue(void)
+{
+	struct virtio_blk_outhdr *req;
+	struct vring_desc *desc;
+	int idx, used_idx, ret;
+	size_t size, len;
+	uint8_t status;
+
+	if (next_idx == vring.avail->idx)
+		return 0;
+
+	idx = vring.avail->ring[next_idx % vring.num];
+
+	desc = &vring.desc[idx];
+	assert(desc->len == sizeof(*req));
+	assert(desc->flags & 1);
+	req = shmem + desc->addr;
+
+	len = 1;
+
+	switch (req->type) {
+	case VIRTIO_BLK_T_IN:
+		desc = &vring.desc[desc->next];
+		assert(desc->flags & 1);
+		size = desc->len;
+		ret = pread(image_fd, shmem + desc->addr, size,
+			    req->sector * 512);
+		if (ret == size) {
+			status = VIRTIO_BLK_S_OK;
+			len += size;
+		} else {
+			status = VIRTIO_BLK_S_IOERR;
+		}
+		break;
+	case VIRTIO_BLK_T_OUT:
+		desc = &vring.desc[desc->next];
+		assert(desc->flags & 1);
+		size = desc->len;
+		ret = pwrite(image_fd, shmem + desc->addr, size,
+			     req->sector * 512);
+		status = ret == size ? VIRTIO_BLK_S_OK : VIRTIO_BLK_S_IOERR;
+		break;
+	case VIRTIO_BLK_T_FLUSH:
+		ret = fsync(image_fd);
+		status = ret == 0 ? VIRTIO_BLK_S_OK : VIRTIO_BLK_S_IOERR;
+		break;
+	case VIRTIO_BLK_T_GET_ID:
+		desc = &vring.desc[desc->next];
+		assert(desc->flags & 1);
+		len = desc->len > 0 ? 1 : 0;
+		memset(shmem + desc->addr, 0, len);
+		status = VIRTIO_BLK_S_OK;
+		break;
+	default:
+		printf("unknown request %d\n", req->type);
+		status = VIRTIO_BLK_S_UNSUPP;
+		break;
+	}
+
+	desc = &vring.desc[desc->next];
+	assert(!(desc->flags & 1));
+
+	*(uint8_t *)(shmem + desc->addr) = status;
+
+	used_idx = vring.used->idx % vring.num;
+	vring.used->ring[used_idx].id = idx;
+	vring.used->ring[used_idx].len = len;
+
+	__sync_synchronize();
+	vring.used->idx++;
+	next_idx++;
+
+	vb->queue_event = 1;
+	__sync_synchronize();
+	mmio_write32(&regs->doorbell,
+		     (peer_id << 16) | vb->queue_config.driver_vector);
+
+	return 1;
+}
+
+static int process_write_transaction(void)
+{
+	switch (vb->write_transaction) {
+	case 0:
+		return 0;
+	case VI_REG_OFFSET(device_features_sel):
+		printf("device_features_sel: %d\n", vb->device_features_sel);
+		if (vb->device_features_sel == 1) {
+			vb->device_features =
+				(1 << (VIRTIO_F_VERSION_1 - 32)) |
+				(1 << (VIRTIO_F_IOMMU_PLATFORM - 32)) |
+				(1 << (VIRTIO_F_ORDER_PLATFORM - 32));
+		} else {
+			vb->device_features =
+				(1 << VIRTIO_BLK_F_SIZE_MAX) |
+				(1 << VIRTIO_BLK_F_SEG_MAX) |
+				(1 << VIRTIO_BLK_F_FLUSH);
+		}
+		break;
+	case VI_REG_OFFSET(driver_features_sel):
+		printf("driver_features_sel: %d\n", vb->driver_features_sel);
+		break;
+	case VI_REG_OFFSET(driver_features):
+		printf("driver_features[%d]: 0x%x\n", vb->driver_features_sel,
+		       vb->driver_features);
+		break;
+	case VI_REG_OFFSET(queue_sel):
+		printf("queue_sel: %d\n", vb->queue_sel);
+		break;
+	case VI_REG_OFFSET(queue_config.size):
+		printf("queue size: %d\n", vb->queue_config.size);
+		break;
+	case VI_REG_OFFSET(queue_config.driver_vector):
+		printf("queue driver vector: %d\n",
+		       vb->queue_config.driver_vector);
+		break;
+	case VI_REG_OFFSET(queue_config.enable):
+		printf("queue enable: %d\n", vb->queue_config.enable);
+		if (vb->queue_config.enable) {
+			vring.num = vb->queue_config.size;
+			vring.desc = shmem + vb->queue_config.desc;
+			vring.avail = shmem + vb->queue_config.driver;
+			vring.used = shmem + vb->queue_config.device;
+			next_idx = 0;
+		}
+		break;
+	case VI_REG_OFFSET(queue_config.desc):
+		printf("queue desc: 0x%llx\n",
+		       (unsigned long long)vb->queue_config.desc);
+		break;
+	case VI_REG_OFFSET(queue_config.driver):
+		printf("queue driver: 0x%llx\n",
+		       (unsigned long long)vb->queue_config.driver);
+		break;
+	case VI_REG_OFFSET(queue_config.device):
+		printf("queue device: 0x%llx\n",
+		       (unsigned long long)vb->queue_config.device);
+		break;
+	case VI_REG_OFFSET(device_status):
+		printf("device_status: 0x%x\n", vb->device_status);
+		break;
+	default:
+		printf("unknown write transaction for %x\n",
+		       vb->write_transaction);
+		break;
+	}
+
+	__sync_synchronize();
+	vb->write_transaction = 0;
+
+	return 1;
+}
+
+int main(int argc, char *argv[])
+{
+	int pagesize = getpagesize();
+	unsigned long long shmem_sz;
+	volatile uint32_t *state;
+	int event, size_fd, ret;
+	char sysfs_path[64];
+	char size_str[64];
+	char *uio_devname;
+
+	if (argc < 3) {
+		fprintf(stderr, "usage: %s UIO-DEVICE IMAGE\n", argv[0]);
+		return 1;
+	}
+
+	image_fd = open(argv[2], O_RDWR);
+	if (image_fd < 0)
+		error(1, errno, "cannot open %s", argv[2]);
+
+	ret = fstat(image_fd, &image_stat);
+	if (ret < 0)
+		error(1, errno, "fstat failed");
+
+	uio_fd = open(argv[1], O_RDWR);
+	if (uio_fd < 0)
+		error(1, errno, "cannot open %s", argv[1]);
+
+	regs = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, uio_fd, 0);
+	if (!regs)
+		error(1, errno, "mmap of registers failed");
+	state = mmap(NULL, 4096, PROT_READ, MAP_SHARED, uio_fd, pagesize);
+	if (!state)
+		error(1, errno, "mmap of state table failed");
+
+	uio_devname = strstr(argv[1], "/uio");
+	snprintf(sysfs_path, sizeof(sysfs_path),
+		 "/sys/class/uio%s/maps/map2/size",
+		 uio_devname);
+	size_fd = open(sysfs_path, O_RDONLY);
+	if (size_fd < 0)
+		error(1, errno, "cannot open %s", sysfs_path);
+	if (read(size_fd, size_str, sizeof(size_str)) < 0)
+		error(1, errno, "read from %s failed", sysfs_path);
+	shmem_sz = strtoll(size_str, NULL, 16);
+
+	shmem = mmap(NULL, shmem_sz, PROT_READ | PROT_WRITE, MAP_SHARED,
+		     uio_fd, 2 * pagesize);
+	if (!shmem)
+		error(1, errno, "mmap of shared memory failed");
+
+	peer_id = !mmio_read32(&regs->id);
+
+	mmio_write32(&regs->int_control, 1);
+
+	while (1) {
+		mmio_write32(&regs->state, VIRTIO_STATE_RESET);
+		while (state[peer_id] != VIRTIO_STATE_RESET) {
+			printf("Waiting for peer to reset...\n");
+			wait_for_interrupt(regs);
+		}
+
+		vb = shmem;
+		memset(vb, 0, sizeof(*vb));
+		vb->revision = 1;
+		vb->size = sizeof(*vb);
+
+		memset(&vb->queue_config, 0, sizeof(vb->queue_config));
+		vb->queue_config.size = 8;
+		vb->queue_config.device_vector = 1;
+
+		vb->config.capacity = image_stat.st_size / 512;
+		vb->config.size_max = (shmem_sz / 8) & ~(pagesize - 1);
+		vb->config.seg_max = 1;
+
+		mmio_write32(&regs->state, VIRTIO_STATE_READY);
+		while (state[peer_id] != VIRTIO_STATE_READY) {
+			printf("Waiting for peer to be ready...\n");
+			wait_for_interrupt(regs);
+		}
+
+		printf("Starting virtio device\n");
+
+		while (state[peer_id] == VIRTIO_STATE_READY) {
+			event = process_write_transaction();
+
+			if (vb->device_status == 0xf)
+				event |= process_queue();
+
+			if (!event)
+				wait_for_interrupt(regs);
+		}
+	}
+}
diff --git a/tools/virtio/virtio-ivshmem-console.c b/tools/virtio/virtio-ivshmem-console.c
new file mode 100644
index 000000000..55232d6b8
--- /dev/null
+++ b/tools/virtio/virtio-ivshmem-console.c
@@ -0,0 +1,397 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Virtio console over uio_ivshmem back-end device
+ *
+ * Copyright (c) Siemens AG, 2019
+ */
+
+/*
+ * HACK warnings:
+ *  - little-endian hosts only
+ *  - no proper input validation (specifically addresses)
+ *  - may miss a couple of barriers
+ *  - ignores a couple of mandatory properties, e.g. notification control
+ *  - could implement some optional console features
+ */
+
+#include <errno.h>
+#include <error.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <termios.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <linux/virtio_console.h>
+#include <linux/virtio_ring.h>
+
+#ifndef VIRTIO_F_ORDER_PLATFORM
+#define VIRTIO_F_ORDER_PLATFORM		36
+#endif
+
+struct ivshm_regs {
+	uint32_t id;
+	uint32_t max_peers;
+	uint32_t int_control;
+	uint32_t doorbell;
+	uint32_t state;
+};
+
+#define VIRTIO_STATE_RESET		0
+#define VIRTIO_STATE_READY		1
+
+struct virtio_queue_config {
+	uint16_t size;
+	uint16_t device_vector;
+	uint16_t driver_vector;
+	uint16_t enable;
+	uint64_t desc;
+	uint64_t driver;
+	uint64_t device;
+};
+
+struct virtio_ivshmem_console {
+	uint32_t revision;
+	uint32_t size;
+
+	uint32_t write_transaction;
+
+	uint32_t device_features;
+	uint32_t device_features_sel;
+	uint32_t driver_features;
+	uint32_t driver_features_sel;
+
+	uint32_t queue_sel;
+	struct virtio_queue_config queue_config;
+
+	uint8_t config_event;
+	uint8_t queue_event;
+	uint8_t __reserved[2];
+	uint32_t device_status;
+
+	uint32_t config_generation;
+
+	struct virtio_console_config config;
+};
+
+#define VI_REG_OFFSET(reg) \
+	__builtin_offsetof(struct virtio_ivshmem_console, reg)
+
+static struct ivshm_regs *regs;
+static int uio_fd;
+static struct virtio_ivshmem_console *vc;
+static struct virtio_queue_config queue_config[2];
+static int current_queue;
+static struct vring vring[2];
+static uint16_t next_idx[2];
+static void *shmem;
+static struct termios orig_termios;
+static uint32_t peer_id;
+
+static inline uint32_t mmio_read32(void *address)
+{
+	return *(volatile uint32_t *)address;
+}
+
+static inline void mmio_write32(void *address, uint32_t value)
+{
+	*(volatile uint32_t *)address = value;
+}
+
+static void wait_for_interrupt(struct ivshm_regs *regs)
+{
+	uint32_t dummy;
+
+	if (read(uio_fd, &dummy, 4) < 0)
+		error(1, errno, "UIO read failed");
+	mmio_write32(&regs->int_control, 1);
+}
+
+static int process_rx_queue(void)
+{
+	struct vring_desc *desc;
+	int idx, used_idx, ret;
+
+	if (next_idx[0] == vring[0].avail->idx)
+		return 0;
+
+	idx = vring[0].avail->ring[next_idx[0] % vring[0].num];
+	desc = &vring[0].desc[idx];
+
+	ret = read(STDIN_FILENO, shmem + desc->addr, desc->len);
+	if (ret <= 0)
+		return 0;
+
+	used_idx = vring[0].used->idx % vring[0].num;
+	vring[0].used->ring[used_idx].id = idx;
+	vring[0].used->ring[used_idx].len = ret;
+	__sync_synchronize();
+	vring[0].used->idx++;
+	next_idx[0]++;
+
+	vc->queue_event = 1;
+	__sync_synchronize();
+	mmio_write32(&regs->doorbell,
+		     (peer_id << 16) | queue_config[0].driver_vector);
+
+	return 1;
+}
+
+static int process_tx_queue(void)
+{
+	ssize_t written, remaining, res;
+	struct vring_desc *desc;
+	int idx, used_idx;
+
+	if (next_idx[1] == vring[1].avail->idx)
+		return 0;
+
+	idx = vring[1].avail->ring[next_idx[1] % vring[1].num];
+	desc = &vring[1].desc[idx];
+
+	written = 0;
+	remaining = desc->len;
+	while (remaining > written) {
+		res = write(STDOUT_FILENO, shmem + desc->addr + written,
+			    remaining);
+		if (res > 0) {
+			written += res;
+			remaining -= res;
+		}
+	}
+
+	used_idx = vring[1].used->idx % vring[1].num;
+	vring[1].used->ring[used_idx].id = idx;
+	vring[1].used->ring[used_idx].len = 0;
+
+	__sync_synchronize();
+	vring[1].used->idx++;
+	next_idx[1]++;
+
+	return 1;
+}
+
+static int process_write_transaction(void)
+{
+	unsigned int new_queue;
+
+	switch (vc->write_transaction) {
+	case 0:
+		return 0;
+	case VI_REG_OFFSET(device_features_sel):
+		printf("device_features_sel: %d\n", vc->device_features_sel);
+		if (vc->device_features_sel == 1) {
+			vc->device_features =
+				(1 << (VIRTIO_F_VERSION_1 - 32)) |
+				(1 << (VIRTIO_F_IOMMU_PLATFORM - 32)) |
+				(1 << (VIRTIO_F_ORDER_PLATFORM - 32));
+		} else {
+			vc->device_features = 1 << VIRTIO_CONSOLE_F_SIZE;
+		}
+		break;
+	case VI_REG_OFFSET(driver_features_sel):
+		printf("driver_features_sel: %d\n", vc->driver_features_sel);
+		break;
+	case VI_REG_OFFSET(driver_features):
+		printf("driver_features[%d]: 0x%x\n", vc->driver_features_sel,
+		       vc->driver_features);
+		break;
+	case VI_REG_OFFSET(queue_sel):
+		new_queue = vc->queue_sel;
+		printf("queue_sel: %d\n", new_queue);
+		if (new_queue > 1)
+			break;
+
+		if (current_queue >= 0)
+			memcpy(&queue_config[current_queue], &vc->queue_config,
+			    sizeof(struct virtio_queue_config));
+
+		current_queue = new_queue;
+		memcpy(&vc->queue_config, &queue_config[current_queue],
+		       sizeof(struct virtio_queue_config));
+		break;
+	case VI_REG_OFFSET(queue_config.size):
+		printf("queue size: %d\n", vc->queue_config.size);
+		break;
+	case VI_REG_OFFSET(queue_config.driver_vector):
+		printf("queue driver vector: %d\n",
+		       vc->queue_config.driver_vector);
+		break;
+	case VI_REG_OFFSET(queue_config.enable):
+		printf("queue enable: %d\n", vc->queue_config.enable);
+		if (current_queue >= 0 && vc->queue_config.enable) {
+			memcpy(&queue_config[current_queue], &vc->queue_config,
+			    sizeof(struct virtio_queue_config));
+			vring[current_queue].num = vc->queue_config.size;
+			vring[current_queue].desc =
+				shmem + vc->queue_config.desc;
+			vring[current_queue].avail =
+				shmem + vc->queue_config.driver;
+			vring[current_queue].used =
+				shmem + vc->queue_config.device;
+			next_idx[current_queue] = 0;
+		}
+		break;
+	case VI_REG_OFFSET(queue_config.desc):
+		printf("queue desc: 0x%llx\n",
+		       (unsigned long long)vc->queue_config.desc);
+		break;
+	case VI_REG_OFFSET(queue_config.driver):
+		printf("queue driver: 0x%llx\n",
+		       (unsigned long long)vc->queue_config.driver);
+		break;
+	case VI_REG_OFFSET(queue_config.device):
+		printf("queue device: 0x%llx\n",
+		       (unsigned long long)vc->queue_config.device);
+		break;
+	case VI_REG_OFFSET(device_status):
+		printf("device_status: 0x%x\n", vc->device_status);
+		if (vc->device_status == 0xf) {
+			vc->config_event = 1;
+			__sync_synchronize();
+			mmio_write32(&regs->doorbell, peer_id << 16);
+		}
+		break;
+	default:
+		printf("unknown write transaction for %x\n",
+		       vc->write_transaction);
+		break;
+	}
+
+	__sync_synchronize();
+	vc->write_transaction = 0;
+
+	return 1;
+}
+
+static void restore_stdin(void)
+{
+	tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_termios);
+}
+
+int main(int argc, char *argv[])
+{
+	int pagesize = getpagesize();
+	unsigned long long shmem_sz;
+	volatile uint32_t *state;
+	struct pollfd pollfd[2];
+	int event, size_fd, ret;
+	struct termios termios;
+	struct winsize winsize;
+	char sysfs_path[64];
+	char size_str[64];
+	char *uio_devname;
+
+	if (argc < 2) {
+		fprintf(stderr, "usage: %s UIO-DEVICE\n", argv[0]);
+		return 1;
+	}
+
+	pollfd[0].fd = STDIN_FILENO;
+	pollfd[0].events = POLLIN;
+
+	ret = fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK);
+	if (ret)
+		error(1, errno, "fcntl failed");
+
+	ret = tcgetattr(STDIN_FILENO, &orig_termios);
+	if (ret)
+		error(1, errno, "tcgetattr failed");
+	atexit(restore_stdin);
+	termios = orig_termios;
+	termios.c_iflag &= ~(ICRNL | IXON);
+	termios.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
+	ret = tcsetattr(STDIN_FILENO, TCSAFLUSH, &termios);
+	if (ret)
+		error(1, errno, "tcsetattr failed");
+
+	ret = ioctl(STDOUT_FILENO, TIOCGWINSZ, &winsize);
+	if (ret)
+		error(1, errno, "TIOCGWINSZ failed");
+
+	uio_fd = open(argv[1], O_RDWR);
+	if (uio_fd < 0)
+		error(1, errno, "cannot open %s", argv[1]);
+
+	pollfd[1].fd = uio_fd;
+	pollfd[1].events = POLLIN;
+
+	regs = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, uio_fd, 0);
+	if (!regs)
+		error(1, errno, "mmap of registers failed");
+	state = mmap(NULL, 4096, PROT_READ, MAP_SHARED, uio_fd, pagesize);
+	if (!state)
+		error(1, errno, "mmap of state table failed");
+
+	uio_devname = strstr(argv[1], "/uio");
+	snprintf(sysfs_path, sizeof(sysfs_path),
+		 "/sys/class/uio%s/maps/map2/size",
+		 uio_devname);
+	size_fd = open(sysfs_path, O_RDONLY);
+	if (size_fd < 0)
+		error(1, errno, "cannot open %s", sysfs_path);
+	if (read(size_fd, size_str, sizeof(size_str)) < 0)
+		error(1, errno, "read from %s failed", sysfs_path);
+	shmem_sz = strtoll(size_str, NULL, 16);
+
+	shmem = mmap(NULL, shmem_sz, PROT_READ | PROT_WRITE, MAP_SHARED,
+		     uio_fd, 2 * pagesize);
+	if (!shmem)
+		error(1, errno, "mmap of shared memory failed");
+
+	peer_id = !mmio_read32(&regs->id);
+
+	mmio_write32(&regs->int_control, 1);
+
+	while (1) {
+		mmio_write32(&regs->state, VIRTIO_STATE_RESET);
+		while (state[peer_id] != VIRTIO_STATE_RESET) {
+			printf("Waiting for peer to reset...\n");
+			wait_for_interrupt(regs);
+		}
+
+		vc = shmem;
+		memset(vc, 0, sizeof(*vc));
+		vc->revision = 1;
+		vc->size = sizeof(*vc);
+
+		memset(queue_config, 0, sizeof(queue_config));
+		queue_config[0].size = 8;
+		queue_config[0].device_vector = 0;
+		queue_config[1].size = 8;
+		queue_config[1].device_vector = 0;
+		current_queue = -1;
+
+		vc->config.cols = winsize.ws_col;
+		vc->config.rows = winsize.ws_row;
+
+		mmio_write32(&regs->state, VIRTIO_STATE_READY);
+		while (state[peer_id] != VIRTIO_STATE_READY) {
+			printf("Waiting for peer to be ready...\n");
+			wait_for_interrupt(regs);
+		}
+
+		printf("Starting virtio device\n");
+
+		while (state[peer_id] == VIRTIO_STATE_READY) {
+			event = process_write_transaction();
+
+			if (vc->device_status == 0xf) {
+				event |= process_rx_queue();
+				event |= process_tx_queue();
+			}
+
+			if (!event) {
+				ret = poll(pollfd, 2, -1);
+				if (ret < 0)
+					error(1, errno, "poll failed");
+				if (pollfd[1].revents & POLLIN)
+					wait_for_interrupt(regs);
+			}
+		}
+	}
+}
